<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>quantum++: qpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">quantum++
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A C++11 quantum computing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceqpp.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceqpp_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqpp_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_codes.html">Codes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that defines quantum error correcting codes  <a href="classqpp_1_1_codes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates custom exceptions, used when validating function parameters.  <a href="classqpp_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_gates.html">Gates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that implements most commonly used gates  <a href="classqpp_1_1_gates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_init.html">Init</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that performs additional initializations/cleanups  <a href="classqpp_1_1_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_random_devices.html">RandomDevices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singeleton class that manages the source of randomness in the library.  <a href="classqpp_1_1_random_devices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_states.html">States</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that implements most commonly used states  <a href="classqpp_1_1_states.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures time.  <a href="classqpp_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aad7ccc50a6b139279d7b56d07112b183"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> = std::complex&lt; double &gt;</td></tr>
<tr class="memdesc:aad7ccc50a6b139279d7b56d07112b183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in double precision.  <a href="#aad7ccc50a6b139279d7b56d07112b183">More...</a><br /></td></tr>
<tr class="separator:aad7ccc50a6b139279d7b56d07112b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fdcbcd3a12dd426ceab6d4aec4a281"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a39fdcbcd3a12dd426ceab6d4aec4a281"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a39fdcbcd3a12dd426ceab6d4aec4a281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen matrix over the field specified by <em>Scalar</em>.  <a href="#a39fdcbcd3a12dd426ceab6d4aec4a281">More...</a><br /></td></tr>
<tr class="separator:a39fdcbcd3a12dd426ceab6d4aec4a281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23060a9e83c7da740a4459153dbd2c41"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a23060a9e83c7da740a4459153dbd2c41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a23060a9e83c7da740a4459153dbd2c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen column vector over the field specified by <em>Scalar</em>.  <a href="#a23060a9e83c7da740a4459153dbd2c41">More...</a><br /></td></tr>
<tr class="separator:a23060a9e83c7da740a4459153dbd2c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc6fdb793d3e2fcc393ac909ecb421d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a7fc6fdb793d3e2fcc393ac909ecb421d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7fc6fdb793d3e2fcc393ac909ecb421d">DynRowVect</a> = Eigen::Matrix&lt; Scalar, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a7fc6fdb793d3e2fcc393ac909ecb421d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen row vector over the field specified by <em>Scalar</em>.  <a href="#a7fc6fdb793d3e2fcc393ac909ecb421d">More...</a><br /></td></tr>
<tr class="separator:a7fc6fdb793d3e2fcc393ac909ecb421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add021f91288df8af3125cf4b2c8806e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a> = <a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;</td></tr>
<tr class="memdesc:add021f91288df8af3125cf4b2c8806e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen column vector.  <a href="#add021f91288df8af3125cf4b2c8806e6">More...</a><br /></td></tr>
<tr class="separator:add021f91288df8af3125cf4b2c8806e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31e93771501f862f00d548105e153b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad31e93771501f862f00d548105e153b2">bra</a> = <a class="el" href="namespaceqpp.html#a7fc6fdb793d3e2fcc393ac909ecb421d">DynRowVect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;</td></tr>
<tr class="memdesc:ad31e93771501f862f00d548105e153b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen row vector.  <a href="#ad31e93771501f862f00d548105e153b2">More...</a><br /></td></tr>
<tr class="separator:ad31e93771501f862f00d548105e153b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7b2a88cebcdddfde04c087eecf1328"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> = <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;</td></tr>
<tr class="memdesc:a8b7b2a88cebcdddfde04c087eecf1328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen matrix.  <a href="#a8b7b2a88cebcdddfde04c087eecf1328">More...</a><br /></td></tr>
<tr class="separator:a8b7b2a88cebcdddfde04c087eecf1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d63fc80c90b84ab9ab7062f2d82d86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> = <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; double &gt;</td></tr>
<tr class="memdesc:a31d63fc80c90b84ab9ab7062f2d82d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real (double precision) dynamic Eigen matrix.  <a href="#a31d63fc80c90b84ab9ab7062f2d82d86">More...</a><br /></td></tr>
<tr class="separator:a31d63fc80c90b84ab9ab7062f2d82d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a09fc2700e3012040bfb2f273ea4b79e9"><td class="memItemLeft" align="right" valign="top">constexpr std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a09fc2700e3012040bfb2f273ea4b79e9">operator&quot;&quot;_i</a> (unsigned long long int x)</td></tr>
<tr class="memdesc:a09fc2700e3012040bfb2f273ea4b79e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_4.png"/> (integer overload)  <a href="#a09fc2700e3012040bfb2f273ea4b79e9">More...</a><br /></td></tr>
<tr class="separator:a09fc2700e3012040bfb2f273ea4b79e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3f80a89a7844c88f5bc556d40c4909"><td class="memItemLeft" align="right" valign="top">constexpr std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2a3f80a89a7844c88f5bc556d40c4909">operator&quot;&quot;_i</a> (long double x)</td></tr>
<tr class="memdesc:a2a3f80a89a7844c88f5bc556d40c4909"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_4.png"/> (real overload)  <a href="#a2a3f80a89a7844c88f5bc556d40c4909">More...</a><br /></td></tr>
<tr class="separator:a2a3f80a89a7844c88f5bc556d40c4909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66175b7225b388d8851c04171fc7a141"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a66175b7225b388d8851c04171fc7a141">omega</a> (std::size_t D)</td></tr>
<tr class="memdesc:a66175b7225b388d8851c04171fc7a141"><td class="mdescLeft">&#160;</td><td class="mdescRight">D-th root of unity.  <a href="#a66175b7225b388d8851c04171fc7a141">More...</a><br /></td></tr>
<tr class="separator:a66175b7225b388d8851c04171fc7a141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810c85eb9d8b64d7b42655713d7c16f3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a810c85eb9d8b64d7b42655713d7c16f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a810c85eb9d8b64d7b42655713d7c16f3">schmidtcoeff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a810c85eb9d8b64d7b42655713d7c16f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt coefficients of the bi-partite pure state <em>A</em>.  <a href="#a810c85eb9d8b64d7b42655713d7c16f3">More...</a><br /></td></tr>
<tr class="separator:a810c85eb9d8b64d7b42655713d7c16f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b14c1fbfface136d6c42fe28461c3a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a08b14c1fbfface136d6c42fe28461c3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a08b14c1fbfface136d6c42fe28461c3a">schmidtU</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a08b14c1fbfface136d6c42fe28461c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt basis on Alice's side.  <a href="#a08b14c1fbfface136d6c42fe28461c3a">More...</a><br /></td></tr>
<tr class="separator:a08b14c1fbfface136d6c42fe28461c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015680bd06d6832f6c1e8b314a74339f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a015680bd06d6832f6c1e8b314a74339f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a015680bd06d6832f6c1e8b314a74339f">schmidtV</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a015680bd06d6832f6c1e8b314a74339f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt basis on Bob's side.  <a href="#a015680bd06d6832f6c1e8b314a74339f">More...</a><br /></td></tr>
<tr class="separator:a015680bd06d6832f6c1e8b314a74339f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23896bc52b516135d0ce545f8149bfc"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad23896bc52b516135d0ce545f8149bfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad23896bc52b516135d0ce545f8149bfc">schmidtprob</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:ad23896bc52b516135d0ce545f8149bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt probabilities of the bi-partite pure state <em>A</em>.  <a href="#ad23896bc52b516135d0ce545f8149bfc">More...</a><br /></td></tr>
<tr class="separator:ad23896bc52b516135d0ce545f8149bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e461b037fcb585462fa4556d792e45"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a37e461b037fcb585462fa4556d792e45"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a37e461b037fcb585462fa4556d792e45">entanglement</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a37e461b037fcb585462fa4556d792e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entanglement of the bi-partite pure state <em>A</em>.  <a href="#a37e461b037fcb585462fa4556d792e45">More...</a><br /></td></tr>
<tr class="separator:a37e461b037fcb585462fa4556d792e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100bf63d3dabba74e049aff37ea7e383"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a100bf63d3dabba74e049aff37ea7e383"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a100bf63d3dabba74e049aff37ea7e383">gconcurrence</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a100bf63d3dabba74e049aff37ea7e383"><td class="mdescLeft">&#160;</td><td class="mdescRight">G-concurrence of the bi-partite pure state <em>A</em>.  <a href="#a100bf63d3dabba74e049aff37ea7e383">More...</a><br /></td></tr>
<tr class="separator:a100bf63d3dabba74e049aff37ea7e383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ecdcfef5ce5a89efbebf0f4354be36"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae5ecdcfef5ce5a89efbebf0f4354be36"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae5ecdcfef5ce5a89efbebf0f4354be36">negativity</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:ae5ecdcfef5ce5a89efbebf0f4354be36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negativity of the bi-partite mixed state <em>A</em>.  <a href="#ae5ecdcfef5ce5a89efbebf0f4354be36">More...</a><br /></td></tr>
<tr class="separator:ae5ecdcfef5ce5a89efbebf0f4354be36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8b627b60cfe29f6062776d088cb889"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aba8b627b60cfe29f6062776d088cb889"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aba8b627b60cfe29f6062776d088cb889">lognegativity</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:aba8b627b60cfe29f6062776d088cb889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithmic negativity of the bi-partite mixed state <em>A</em>.  <a href="#aba8b627b60cfe29f6062776d088cb889">More...</a><br /></td></tr>
<tr class="separator:aba8b627b60cfe29f6062776d088cb889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b">concurrence</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wootters concurrence of the bi-partite qubit mixed state <em>A</em>.  <a href="#a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b">More...</a><br /></td></tr>
<tr class="separator:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3642532b9a23be1c7f7cafa4629e6d5d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3642532b9a23be1c7f7cafa4629e6d5d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3642532b9a23be1c7f7cafa4629e6d5d">shannon</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a3642532b9a23be1c7f7cafa4629e6d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shannon/von-Neumann entropy of the probability distribution/density matrix <em>A</em>.  <a href="#a3642532b9a23be1c7f7cafa4629e6d5d">More...</a><br /></td></tr>
<tr class="separator:a3642532b9a23be1c7f7cafa4629e6d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991bc6df4280943452bfbedafa65b9f7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a991bc6df4280943452bfbedafa65b9f7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a991bc6df4280943452bfbedafa65b9f7">renyi</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double alpha)</td></tr>
<tr class="memdesc:a991bc6df4280943452bfbedafa65b9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renyi- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy of the probability distribution/density matrix <em>A</em>, for <img class="formulaInl" alt="$ \alpha\geq 0$" src="form_11.png"/>.  <a href="#a991bc6df4280943452bfbedafa65b9f7">More...</a><br /></td></tr>
<tr class="separator:a991bc6df4280943452bfbedafa65b9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4980e688af46b3b1a96c2f12c9849cd0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4980e688af46b3b1a96c2f12c9849cd0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4980e688af46b3b1a96c2f12c9849cd0">tsallis</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double alpha)</td></tr>
<tr class="memdesc:a4980e688af46b3b1a96c2f12c9849cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tsallis- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy of the probability distribution/density matrix <em>A</em>, for <img class="formulaInl" alt="$ \alpha\geq 0$" src="form_11.png"/>.  <a href="#a4980e688af46b3b1a96c2f12c9849cd0">More...</a><br /></td></tr>
<tr class="separator:a4980e688af46b3b1a96c2f12c9849cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80473c412499e9a120c4597a34add129"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a80473c412499e9a120c4597a34add129"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a80473c412499e9a120c4597a34add129">qmutualinfo</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsysA, const std::vector&lt; std::size_t &gt; &amp;subsysB, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a80473c412499e9a120c4597a34add129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantum mutual information between 2 subsystems of a composite system.  <a href="#a80473c412499e9a120c4597a34add129">More...</a><br /></td></tr>
<tr class="separator:a80473c412499e9a120c4597a34add129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b652e3ea4b9748204359a69588a8c91"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7b652e3ea4b9748204359a69588a8c91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7b652e3ea4b9748204359a69588a8c91">transpose</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a7b652e3ea4b9748204359a69588a8c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose.  <a href="#a7b652e3ea4b9748204359a69588a8c91">More...</a><br /></td></tr>
<tr class="separator:a7b652e3ea4b9748204359a69588a8c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf2df9d3f5c18623eab26ab84ea7418"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acbf2df9d3f5c18623eab26ab84ea7418"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#acbf2df9d3f5c18623eab26ab84ea7418">conjugate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:acbf2df9d3f5c18623eab26ab84ea7418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate.  <a href="#acbf2df9d3f5c18623eab26ab84ea7418">More...</a><br /></td></tr>
<tr class="separator:acbf2df9d3f5c18623eab26ab84ea7418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac541afad6657467d9bd83c69345880a2"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac541afad6657467d9bd83c69345880a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2">adjoint</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:ac541afad6657467d9bd83c69345880a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjoint.  <a href="#ac541afad6657467d9bd83c69345880a2">More...</a><br /></td></tr>
<tr class="separator:ac541afad6657467d9bd83c69345880a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba74531ce09b81f5ea1afbb9c94a6de"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4ba74531ce09b81f5ea1afbb9c94a6de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4ba74531ce09b81f5ea1afbb9c94a6de">inverse</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a4ba74531ce09b81f5ea1afbb9c94a6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse.  <a href="#a4ba74531ce09b81f5ea1afbb9c94a6de">More...</a><br /></td></tr>
<tr class="separator:a4ba74531ce09b81f5ea1afbb9c94a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1daff5450728504da1fdfedf8d8b54"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1e1daff5450728504da1fdfedf8d8b54"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54">trace</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a1e1daff5450728504da1fdfedf8d8b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace.  <a href="#a1e1daff5450728504da1fdfedf8d8b54">More...</a><br /></td></tr>
<tr class="separator:a1e1daff5450728504da1fdfedf8d8b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4f6e426d47b5bf66afc0f7cc0321e0eb">det</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determinant.  <a href="#a4f6e426d47b5bf66afc0f7cc0321e0eb">More...</a><br /></td></tr>
<tr class="separator:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a129545b05e69dd7f4c60b009ca183"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a95a129545b05e69dd7f4c60b009ca183"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183">logdet</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a95a129545b05e69dd7f4c60b009ca183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithm of the determinant.  <a href="#a95a129545b05e69dd7f4c60b009ca183">More...</a><br /></td></tr>
<tr class="separator:a95a129545b05e69dd7f4c60b009ca183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a92e8a327ff86f87c6236965103797"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a48a92e8a327ff86f87c6236965103797"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a48a92e8a327ff86f87c6236965103797">sum</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a48a92e8a327ff86f87c6236965103797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum of <em>A</em>.  <a href="#a48a92e8a327ff86f87c6236965103797">More...</a><br /></td></tr>
<tr class="separator:a48a92e8a327ff86f87c6236965103797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78595ec429a5df51dbe682cdb9711d9c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a78595ec429a5df51dbe682cdb9711d9c"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a78595ec429a5df51dbe682cdb9711d9c">prod</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a78595ec429a5df51dbe682cdb9711d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise product of <em>A</em>.  <a href="#a78595ec429a5df51dbe682cdb9711d9c">More...</a><br /></td></tr>
<tr class="separator:a78595ec429a5df51dbe682cdb9711d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e4740854c958579228593dd639aa6c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af2e4740854c958579228593dd639aa6c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af2e4740854c958579228593dd639aa6c">norm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:af2e4740854c958579228593dd639aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frobenius norm.  <a href="#af2e4740854c958579228593dd639aa6c">More...</a><br /></td></tr>
<tr class="separator:af2e4740854c958579228593dd639aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927d85e57656ffb19ddb149985fa52df"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a927d85e57656ffb19ddb149985fa52df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df">evals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a927d85e57656ffb19ddb149985fa52df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalues.  <a href="#a927d85e57656ffb19ddb149985fa52df">More...</a><br /></td></tr>
<tr class="separator:a927d85e57656ffb19ddb149985fa52df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8">evects</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvectors.  <a href="#acc9597bacc39c501eb8e2e5e8530fcd8">More...</a><br /></td></tr>
<tr class="separator:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96eb6e12c5bc0c544663f6705bc1c950"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a96eb6e12c5bc0c544663f6705bc1c950"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a96eb6e12c5bc0c544663f6705bc1c950">hevals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a96eb6e12c5bc0c544663f6705bc1c950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian eigenvalues.  <a href="#a96eb6e12c5bc0c544663f6705bc1c950">More...</a><br /></td></tr>
<tr class="separator:a96eb6e12c5bc0c544663f6705bc1c950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeadaf6395c78a52339bec119c4a331b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:abeadaf6395c78a52339bec119c4a331b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#abeadaf6395c78a52339bec119c4a331b">hevects</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:abeadaf6395c78a52339bec119c4a331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian eigenvectors.  <a href="#abeadaf6395c78a52339bec119c4a331b">More...</a><br /></td></tr>
<tr class="separator:abeadaf6395c78a52339bec119c4a331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e1199f56fdc39622a17c949d6ede5a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a51e1199f56fdc39622a17c949d6ede5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a51e1199f56fdc39622a17c949d6ede5a">svals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a51e1199f56fdc39622a17c949d6ede5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular values.  <a href="#a51e1199f56fdc39622a17c949d6ede5a">More...</a><br /></td></tr>
<tr class="separator:a51e1199f56fdc39622a17c949d6ede5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c070beade098fa8f26440791cc8840"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a33c070beade098fa8f26440791cc8840"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a33c070beade098fa8f26440791cc8840">svdU</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a33c070beade098fa8f26440791cc8840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left singular vectors.  <a href="#a33c070beade098fa8f26440791cc8840">More...</a><br /></td></tr>
<tr class="separator:a33c070beade098fa8f26440791cc8840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a285eda1b8ec8614398dd731e5e3a89ed">svdV</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a285eda1b8ec8614398dd731e5e3a89ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right singular vectors.  <a href="#a285eda1b8ec8614398dd731e5e3a89ed">More...</a><br /></td></tr>
<tr class="separator:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659b50e01fa0b26089d3944c2c56601a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a659b50e01fa0b26089d3944c2c56601a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a">funm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>(*f)(const <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &amp;))</td></tr>
<tr class="memdesc:a659b50e01fa0b26089d3944c2c56601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional calculus f(A)  <a href="#a659b50e01fa0b26089d3944c2c56601a">More...</a><br /></td></tr>
<tr class="separator:a659b50e01fa0b26089d3944c2c56601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a83e2b23bc11e3cb8dd6909969af7377c">sqrtm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a83e2b23bc11e3cb8dd6909969af7377c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix square root.  <a href="#a83e2b23bc11e3cb8dd6909969af7377c">More...</a><br /></td></tr>
<tr class="separator:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3a4cb16d97f9cc763bd133b64f2b6f6d">absm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix absolut value.  <a href="#a3a4cb16d97f9cc763bd133b64f2b6f6d">More...</a><br /></td></tr>
<tr class="separator:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6855dd77c49ae0b96baf10c12b4bc722">expm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a6855dd77c49ae0b96baf10c12b4bc722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix exponential.  <a href="#a6855dd77c49ae0b96baf10c12b4bc722">More...</a><br /></td></tr>
<tr class="separator:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683ff6f7df206be1a6105317c4c8ed70"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a683ff6f7df206be1a6105317c4c8ed70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a683ff6f7df206be1a6105317c4c8ed70">logm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a683ff6f7df206be1a6105317c4c8ed70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix logarithm.  <a href="#a683ff6f7df206be1a6105317c4c8ed70">More...</a><br /></td></tr>
<tr class="separator:a683ff6f7df206be1a6105317c4c8ed70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be6e812878479d6acbd25cf5ae387c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a78be6e812878479d6acbd25cf5ae387c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a78be6e812878479d6acbd25cf5ae387c">sinm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a78be6e812878479d6acbd25cf5ae387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix sin.  <a href="#a78be6e812878479d6acbd25cf5ae387c">More...</a><br /></td></tr>
<tr class="separator:a78be6e812878479d6acbd25cf5ae387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c7a2f9f27121178519ddba186fbcd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a369c7a2f9f27121178519ddba186fbcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a369c7a2f9f27121178519ddba186fbcd">cosm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a369c7a2f9f27121178519ddba186fbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix cos.  <a href="#a369c7a2f9f27121178519ddba186fbcd">More...</a><br /></td></tr>
<tr class="separator:a369c7a2f9f27121178519ddba186fbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a62d7f0db6a049f254c2a7a77af8eb29e">spectralpowm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> z)</td></tr>
<tr class="memdesc:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix power.  <a href="#a62d7f0db6a049f254c2a7a77af8eb29e">More...</a><br /></td></tr>
<tr class="separator:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4fd08d05e83656e8ce3153fe5a6f0b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3b4fd08d05e83656e8ce3153fe5a6f0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b">powm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::size_t n)</td></tr>
<tr class="memdesc:a3b4fd08d05e83656e8ce3153fe5a6f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix power.  <a href="#a3b4fd08d05e83656e8ce3153fe5a6f0b">More...</a><br /></td></tr>
<tr class="separator:a3b4fd08d05e83656e8ce3153fe5a6f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8251985eb390022a0116f6572a82ea58"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8251985eb390022a0116f6572a82ea58"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8251985eb390022a0116f6572a82ea58">schatten</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::size_t p)</td></tr>
<tr class="memdesc:a8251985eb390022a0116f6572a82ea58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schatten norm.  <a href="#a8251985eb390022a0116f6572a82ea58">More...</a><br /></td></tr>
<tr class="separator:a8251985eb390022a0116f6572a82ea58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a93794f1719077733b79cc9f2f1df"><td class="memTemplParams" colspan="2">template&lt;typename OutputScalar , typename Derived &gt; </td></tr>
<tr class="memitem:af68a93794f1719077733b79cc9f2f1df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; OutputScalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af68a93794f1719077733b79cc9f2f1df">cwise</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, OutputScalar(*f)(const typename Derived::Scalar &amp;))</td></tr>
<tr class="memdesc:af68a93794f1719077733b79cc9f2f1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor.  <a href="#af68a93794f1719077733b79cc9f2f1df">More...</a><br /></td></tr>
<tr class="separator:af68a93794f1719077733b79cc9f2f1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2bafdce8302c9ac34ab328ec84a3f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b2bafdce8302c9ac34ab328ec84a3f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename T::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7">kron</a> (const T &amp;head)</td></tr>
<tr class="memdesc:a3b2bafdce8302c9ac34ab328ec84a3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product.  <a href="#a3b2bafdce8302c9ac34ab328ec84a3f7">More...</a><br /></td></tr>
<tr class="separator:a3b2bafdce8302c9ac34ab328ec84a3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf9a3f8918581dc2f6cc4972e22402e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9cf9a3f8918581dc2f6cc4972e22402e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename T::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9cf9a3f8918581dc2f6cc4972e22402e">kron</a> (const T &amp;head, const Args &amp;...tail)</td></tr>
<tr class="memdesc:a9cf9a3f8918581dc2f6cc4972e22402e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product.  <a href="#a9cf9a3f8918581dc2f6cc4972e22402e">More...</a><br /></td></tr>
<tr class="separator:a9cf9a3f8918581dc2f6cc4972e22402e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec55628dde4007629317cfa104b1073f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aec55628dde4007629317cfa104b1073f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aec55628dde4007629317cfa104b1073f">kron</a> (const std::vector&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:aec55628dde4007629317cfa104b1073f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product.  <a href="#aec55628dde4007629317cfa104b1073f">More...</a><br /></td></tr>
<tr class="separator:aec55628dde4007629317cfa104b1073f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c7ebe19908ccaafbf5471f60926c7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad11c7ebe19908ccaafbf5471f60926c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad11c7ebe19908ccaafbf5471f60926c7">kron</a> (const std::initializer_list&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:ad11c7ebe19908ccaafbf5471f60926c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product.  <a href="#ad11c7ebe19908ccaafbf5471f60926c7">More...</a><br /></td></tr>
<tr class="separator:ad11c7ebe19908ccaafbf5471f60926c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac695bd8e27cfe03265b550f62c394adb"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac695bd8e27cfe03265b550f62c394adb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac695bd8e27cfe03265b550f62c394adb">kronpow</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::size_t n)</td></tr>
<tr class="memdesc:ac695bd8e27cfe03265b550f62c394adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker power.  <a href="#ac695bd8e27cfe03265b550f62c394adb">More...</a><br /></td></tr>
<tr class="separator:ac695bd8e27cfe03265b550f62c394adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5c91b44c2437627777140980cac940"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1f5c91b44c2437627777140980cac940"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940">reshape</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::size_t rows, std::size_t cols)</td></tr>
<tr class="memdesc:a1f5c91b44c2437627777140980cac940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape.  <a href="#a1f5c91b44c2437627777140980cac940">More...</a><br /></td></tr>
<tr class="separator:a1f5c91b44c2437627777140980cac940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e549f73a22004d7868a2392fcddae5f"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a9e549f73a22004d7868a2392fcddae5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9e549f73a22004d7868a2392fcddae5f">comm</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;B)</td></tr>
<tr class="memdesc:a9e549f73a22004d7868a2392fcddae5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commutator.  <a href="#a9e549f73a22004d7868a2392fcddae5f">More...</a><br /></td></tr>
<tr class="separator:a9e549f73a22004d7868a2392fcddae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca142339e1a19e0f08488dbc3cf3e71"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a0ca142339e1a19e0f08488dbc3cf3e71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0ca142339e1a19e0f08488dbc3cf3e71">anticomm</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;B)</td></tr>
<tr class="memdesc:a0ca142339e1a19e0f08488dbc3cf3e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anti-commutator.  <a href="#a0ca142339e1a19e0f08488dbc3cf3e71">More...</a><br /></td></tr>
<tr class="separator:a0ca142339e1a19e0f08488dbc3cf3e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4324f5182395adab0e36eede35e4fe6b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4324f5182395adab0e36eede35e4fe6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4324f5182395adab0e36eede35e4fe6b">prj</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;V)</td></tr>
<tr class="memdesc:a4324f5182395adab0e36eede35e4fe6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector.  <a href="#a4324f5182395adab0e36eede35e4fe6b">More...</a><br /></td></tr>
<tr class="separator:a4324f5182395adab0e36eede35e4fe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743da9600f080b2d31951a91b0e2e59a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a743da9600f080b2d31951a91b0e2e59a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a743da9600f080b2d31951a91b0e2e59a">grams</a> (const std::vector&lt; Derived &gt; &amp;Vs)</td></tr>
<tr class="memdesc:a743da9600f080b2d31951a91b0e2e59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization.  <a href="#a743da9600f080b2d31951a91b0e2e59a">More...</a><br /></td></tr>
<tr class="separator:a743da9600f080b2d31951a91b0e2e59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad478cc51fbe3e7843460f54eecb0f726"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad478cc51fbe3e7843460f54eecb0f726"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad478cc51fbe3e7843460f54eecb0f726">grams</a> (const std::initializer_list&lt; Derived &gt; &amp;Vs)</td></tr>
<tr class="memdesc:ad478cc51fbe3e7843460f54eecb0f726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization.  <a href="#ad478cc51fbe3e7843460f54eecb0f726">More...</a><br /></td></tr>
<tr class="separator:ad478cc51fbe3e7843460f54eecb0f726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46120dde34a67d551a3e118f908fdcd1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a46120dde34a67d551a3e118f908fdcd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a46120dde34a67d551a3e118f908fdcd1">grams</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a46120dde34a67d551a3e118f908fdcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization.  <a href="#a46120dde34a67d551a3e118f908fdcd1">More...</a><br /></td></tr>
<tr class="separator:a46120dde34a67d551a3e118f908fdcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe051c49a6c9c5a1cbb6401f95143a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afbe051c49a6c9c5a1cbb6401f95143a8">n2multiidx</a> (std::size_t n, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:afbe051c49a6c9c5a1cbb6401f95143a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-negative integer index to multi-index.  <a href="#afbe051c49a6c9c5a1cbb6401f95143a8">More...</a><br /></td></tr>
<tr class="separator:afbe051c49a6c9c5a1cbb6401f95143a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19badf6efe78383485b2ba28e4136bb7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a19badf6efe78383485b2ba28e4136bb7">multiidx2n</a> (const std::vector&lt; std::size_t &gt; &amp;midx, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a19badf6efe78383485b2ba28e4136bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-index to non-negative integer index.  <a href="#a19badf6efe78383485b2ba28e4136bb7">More...</a><br /></td></tr>
<tr class="separator:a19badf6efe78383485b2ba28e4136bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ade48c09bb33df893d7ff62a098374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a94ade48c09bb33df893d7ff62a098374">mket</a> (const std::vector&lt; std::size_t &gt; &amp;mask, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a94ade48c09bb33df893d7ff62a098374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-partite qudit ket.  <a href="#a94ade48c09bb33df893d7ff62a098374">More...</a><br /></td></tr>
<tr class="separator:a94ade48c09bb33df893d7ff62a098374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b2d9874a3688fbb56eaff32f9acc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab7b2d9874a3688fbb56eaff32f9acc7d">mket</a> (const std::vector&lt; std::size_t &gt; &amp;mask, std::size_t d=2)</td></tr>
<tr class="memdesc:ab7b2d9874a3688fbb56eaff32f9acc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-partite qudit ket.  <a href="#ab7b2d9874a3688fbb56eaff32f9acc7d">More...</a><br /></td></tr>
<tr class="separator:ab7b2d9874a3688fbb56eaff32f9acc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af881bc85f432ae9ee8a41a34b9ffae07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af881bc85f432ae9ee8a41a34b9ffae07">mprj</a> (const std::vector&lt; std::size_t &gt; &amp;mask, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:af881bc85f432ae9ee8a41a34b9ffae07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector onto multi-partite qudit ket.  <a href="#af881bc85f432ae9ee8a41a34b9ffae07">More...</a><br /></td></tr>
<tr class="separator:af881bc85f432ae9ee8a41a34b9ffae07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933550ccd7424593b89a7682469f3fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a933550ccd7424593b89a7682469f3fed">mprj</a> (const std::vector&lt; std::size_t &gt; &amp;mask, std::size_t d=2)</td></tr>
<tr class="memdesc:a933550ccd7424593b89a7682469f3fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector onto multi-partite qudit ket.  <a href="#a933550ccd7424593b89a7682469f3fed">More...</a><br /></td></tr>
<tr class="separator:a933550ccd7424593b89a7682469f3fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9825a190c56286a68989b67620bbb9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a3e9825a190c56286a68989b67620bbb9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3e9825a190c56286a68989b67620bbb9">abssq</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a3e9825a190c56286a68989b67620bbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolut values squared of a range of complex numbers.  <a href="#a3e9825a190c56286a68989b67620bbb9">More...</a><br /></td></tr>
<tr class="separator:a3e9825a190c56286a68989b67620bbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7149763a7b4353138499b349d967303d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7149763a7b4353138499b349d967303d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7149763a7b4353138499b349d967303d">abssq</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;V)</td></tr>
<tr class="memdesc:a7149763a7b4353138499b349d967303d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolut values squared of a column vector.  <a href="#a7149763a7b4353138499b349d967303d">More...</a><br /></td></tr>
<tr class="separator:a7149763a7b4353138499b349d967303d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beed28e8ce824a89484c6aeeb9ea24e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a9beed28e8ce824a89484c6aeeb9ea24e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9beed28e8ce824a89484c6aeeb9ea24e">sum</a> (InputIterator first, InputIterator last) -&gt; typename InputIterator::value_type</td></tr>
<tr class="memdesc:a9beed28e8ce824a89484c6aeeb9ea24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum of a range.  <a href="#a9beed28e8ce824a89484c6aeeb9ea24e">More...</a><br /></td></tr>
<tr class="separator:a9beed28e8ce824a89484c6aeeb9ea24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f10cf7a2845946fedfac88e6a9081f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ab7f10cf7a2845946fedfac88e6a9081f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab7f10cf7a2845946fedfac88e6a9081f">prod</a> (InputIterator first, InputIterator last) -&gt; typename InputIterator::value_type</td></tr>
<tr class="memdesc:ab7f10cf7a2845946fedfac88e6a9081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise product of a range.  <a href="#ab7f10cf7a2845946fedfac88e6a9081f">More...</a><br /></td></tr>
<tr class="separator:ab7f10cf7a2845946fedfac88e6a9081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae2e6e9a554f4f553524033258021c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9fae2e6e9a554f4f553524033258021c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; typename <br class="typebreak" />
Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9fae2e6e9a554f4f553524033258021c">rho2pure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a9fae2e6e9a554f4f553524033258021c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the pure state representation of a matrix proportional to a projector onto a pure state.  <a href="#a9fae2e6e9a554f4f553524033258021c">More...</a><br /></td></tr>
<tr class="separator:a9fae2e6e9a554f4f553524033258021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1805e175751ef749374e3c8499f15d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4f1805e175751ef749374e3c8499f15d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d">disp</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double <a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a>=<a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a>)</td></tr>
<tr class="memdesc:a4f1805e175751ef749374e3c8499f15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen expression ostream manipulator.  <a href="#a4f1805e175751ef749374e3c8499f15d">More...</a><br /></td></tr>
<tr class="separator:a4f1805e175751ef749374e3c8499f15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a815b8e5cf5cd3ab4c463bf53eb550dbf">disp</a> (<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> z, double <a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a>=<a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a>)</td></tr>
<tr class="memdesc:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number ostream manipulator.  <a href="#a815b8e5cf5cd3ab4c463bf53eb550dbf">More...</a><br /></td></tr>
<tr class="separator:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60298648d39542ac44effa9fe73d41c9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a60298648d39542ac44effa9fe73d41c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a><br class="typebreak" />
&lt; InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a60298648d39542ac44effa9fe73d41c9">disp</a> (const InputIterator &amp;first, const InputIterator &amp;last, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;)</td></tr>
<tr class="memdesc:a60298648d39542ac44effa9fe73d41c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range ostream manipulator.  <a href="#a60298648d39542ac44effa9fe73d41c9">More...</a><br /></td></tr>
<tr class="separator:a60298648d39542ac44effa9fe73d41c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ad6985e72b70282708a637cf42e7b"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:afc2ad6985e72b70282708a637cf42e7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
Container::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afc2ad6985e72b70282708a637cf42e7b">disp</a> (const Container &amp;c, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;)</td></tr>
<tr class="memdesc:afc2ad6985e72b70282708a637cf42e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard container ostream manipulator. The container must support std::begin(), std::end() and forward iteration.  <a href="#afc2ad6985e72b70282708a637cf42e7b">More...</a><br /></td></tr>
<tr class="separator:afc2ad6985e72b70282708a637cf42e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e8f13a0bb318a28e1066a8fe5b3ce0"><td class="memTemplParams" colspan="2">template&lt;typename PointerType &gt; </td></tr>
<tr class="memitem:af6e8f13a0bb318a28e1066a8fe5b3ce0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_pointer.html">internal::IOManipPointer</a><br class="typebreak" />
&lt; PointerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af6e8f13a0bb318a28e1066a8fe5b3ce0">disp</a> (const PointerType *p, std::size_t n, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;)</td></tr>
<tr class="memdesc:af6e8f13a0bb318a28e1066a8fe5b3ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-style pointer ostream manipulator.  <a href="#af6e8f13a0bb318a28e1066a8fe5b3ce0">More...</a><br /></td></tr>
<tr class="separator:af6e8f13a0bb318a28e1066a8fe5b3ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238cf516513837235fbc7d7d283f7b78"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a238cf516513837235fbc7d7d283f7b78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a238cf516513837235fbc7d7d283f7b78">save</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::string &amp;fname)</td></tr>
<tr class="memdesc:a238cf516513837235fbc7d7d283f7b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves Eigen expression to a binary file (internal format) in double precision.  <a href="#a238cf516513837235fbc7d7d283f7b78">More...</a><br /></td></tr>
<tr class="separator:a238cf516513837235fbc7d7d283f7b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217e8ae6b09ac3cc89415d4b6204fda6"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a217e8ae6b09ac3cc89415d4b6204fda6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a217e8ae6b09ac3cc89415d4b6204fda6">load</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a217e8ae6b09ac3cc89415d4b6204fda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Eigen matrix from a binary file (internal format) in double precision.  <a href="#a217e8ae6b09ac3cc89415d4b6204fda6">More...</a><br /></td></tr>
<tr class="separator:a217e8ae6b09ac3cc89415d4b6204fda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67d479bd53ef2dafb20db8a2207665c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa67d479bd53ef2dafb20db8a2207665c"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa67d479bd53ef2dafb20db8a2207665c">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:aa67d479bd53ef2dafb20db8a2207665c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#aa67d479bd53ef2dafb20db8a2207665c">More...</a><br /></td></tr>
<tr class="separator:aa67d479bd53ef2dafb20db8a2207665c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e88cbdbcfb198818f5e49dd7c2904a3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3e88cbdbcfb198818f5e49dd7c2904a3"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3e88cbdbcfb198818f5e49dd7c2904a3">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a3e88cbdbcfb198818f5e49dd7c2904a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a3e88cbdbcfb198818f5e49dd7c2904a3">More...</a><br /></td></tr>
<tr class="separator:a3e88cbdbcfb198818f5e49dd7c2904a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9722c7db968d9d2d73360afe8f4f7cd3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9722c7db968d9d2d73360afe8f4f7cd3"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9722c7db968d9d2d73360afe8f4f7cd3">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::size_t d=2)</td></tr>
<tr class="memdesc:a9722c7db968d9d2d73360afe8f4f7cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a9722c7db968d9d2d73360afe8f4f7cd3">More...</a><br /></td></tr>
<tr class="separator:a9722c7db968d9d2d73360afe8f4f7cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14e7a9cbe0187ad6577b32a71ed9ce2"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad14e7a9cbe0187ad6577b32a71ed9ce2"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad14e7a9cbe0187ad6577b32a71ed9ce2">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::size_t d=2)</td></tr>
<tr class="memdesc:ad14e7a9cbe0187ad6577b32a71ed9ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#ad14e7a9cbe0187ad6577b32a71ed9ce2">More...</a><br /></td></tr>
<tr class="separator:ad14e7a9cbe0187ad6577b32a71ed9ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c133827c40b6e615d616442d744cb1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ab5c133827c40b6e615d616442d744cb1"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab5c133827c40b6e615d616442d744cb1">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &amp;U, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:ab5c133827c40b6e615d616442d744cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state <em>A</em> in the orthonormal basis specified by the unitary matrix <em>U</em>.  <a href="#ab5c133827c40b6e615d616442d744cb1">More...</a><br /></td></tr>
<tr class="separator:ab5c133827c40b6e615d616442d744cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b170e9f3a5f8822e5ff27f0023cd1e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a17b170e9f3a5f8822e5ff27f0023cd1e"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a17b170e9f3a5f8822e5ff27f0023cd1e">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &amp;U, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::size_t d=2)</td></tr>
<tr class="memdesc:a17b170e9f3a5f8822e5ff27f0023cd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the part <em>subsys</em> of the multi-partite state <em>A</em> in the orthonormal basis specified by the unitary matrix <em>U</em>.  <a href="#a17b170e9f3a5f8822e5ff27f0023cd1e">More...</a><br /></td></tr>
<tr class="separator:a17b170e9f3a5f8822e5ff27f0023cd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab9e727227257620aab37cf6e7edabd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9ab9e727227257620aab37cf6e7edabd"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9ab9e727227257620aab37cf6e7edabd">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a9ab9e727227257620aab37cf6e7edabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a9ab9e727227257620aab37cf6e7edabd">More...</a><br /></td></tr>
<tr class="separator:a9ab9e727227257620aab37cf6e7edabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb5b9f74f7d1103c6536307dc7e9e60"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7cb5b9f74f7d1103c6536307dc7e9e60"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7cb5b9f74f7d1103c6536307dc7e9e60">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a7cb5b9f74f7d1103c6536307dc7e9e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a7cb5b9f74f7d1103c6536307dc7e9e60">More...</a><br /></td></tr>
<tr class="separator:a7cb5b9f74f7d1103c6536307dc7e9e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf17a94b675f00820fdbc633727c7c0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:abcf17a94b675f00820fdbc633727c7c0"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, <br class="typebreak" />
std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#abcf17a94b675f00820fdbc633727c7c0">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &amp;U)</td></tr>
<tr class="memdesc:abcf17a94b675f00820fdbc633727c7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> in the orthonormal basis specified by the unitary matrix <em>U</em>.  <a href="#abcf17a94b675f00820fdbc633727c7c0">More...</a><br /></td></tr>
<tr class="separator:abcf17a94b675f00820fdbc633727c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a0f3023e1895d22de4e5f3e727e1dd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a84a0f3023e1895d22de4e5f3e727e1dd"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a84a0f3023e1895d22de4e5f3e727e1dd">loadMATLABmatrix</a> (const std::string &amp;mat_file, const std::string &amp;var_name)</td></tr>
<tr class="memdesc:a84a0f3023e1895d22de4e5f3e727e1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an Eigen dynamic matrix from a MATLAB .mat file, generic version.  <a href="#a84a0f3023e1895d22de4e5f3e727e1dd">More...</a><br /></td></tr>
<tr class="separator:a84a0f3023e1895d22de4e5f3e727e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2030161b0158746beaac80612a3464e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa2030161b0158746beaac80612a3464e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa2030161b0158746beaac80612a3464e">loadMATLABmatrix</a> (const std::string &amp;mat_file, const std::string &amp;var_name)</td></tr>
<tr class="memdesc:aa2030161b0158746beaac80612a3464e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an Eigen dynamic matrix from a MATLAB .mat file, specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>)  <a href="#aa2030161b0158746beaac80612a3464e">More...</a><br /></td></tr>
<tr class="separator:aa2030161b0158746beaac80612a3464e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26858bfbbec50369d19270c7bf329afa"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a26858bfbbec50369d19270c7bf329afa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a26858bfbbec50369d19270c7bf329afa">loadMATLABmatrix</a> (const std::string &amp;mat_file, const std::string &amp;var_name)</td></tr>
<tr class="memdesc:a26858bfbbec50369d19270c7bf329afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an Eigen dynamic matrix from a MATLAB .mat file, specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>)  <a href="#a26858bfbbec50369d19270c7bf329afa">More...</a><br /></td></tr>
<tr class="separator:a26858bfbbec50369d19270c7bf329afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d10a1f7c02f69d876a28133893d082"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a38d10a1f7c02f69d876a28133893d082"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a38d10a1f7c02f69d876a28133893d082">saveMATLABmatrix</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::string &amp;mat_file, const std::string &amp;var_name, const std::string &amp;mode)</td></tr>
<tr class="memdesc:a38d10a1f7c02f69d876a28133893d082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an Eigen dynamic matrix to a MATLAB .mat file, generic version.  <a href="#a38d10a1f7c02f69d876a28133893d082">More...</a><br /></td></tr>
<tr class="separator:a38d10a1f7c02f69d876a28133893d082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a40410f15a82495cabcd3641a788cd"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a37a40410f15a82495cabcd3641a788cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a37a40410f15a82495cabcd3641a788cd">saveMATLABmatrix</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> &gt; &amp;A, const std::string &amp;mat_file, const std::string &amp;var_name, const std::string &amp;mode)</td></tr>
<tr class="memdesc:a37a40410f15a82495cabcd3641a788cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an Eigen dynamic matrix to a MATLAB .mat file, specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>)  <a href="#a37a40410f15a82495cabcd3641a788cd">More...</a><br /></td></tr>
<tr class="separator:a37a40410f15a82495cabcd3641a788cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5cc697b513a7f0e5bdab3f357df173"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2f5cc697b513a7f0e5bdab3f357df173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2f5cc697b513a7f0e5bdab3f357df173">saveMATLABmatrix</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;A, const std::string &amp;mat_file, const std::string &amp;var_name, const std::string &amp;mode)</td></tr>
<tr class="memdesc:a2f5cc697b513a7f0e5bdab3f357df173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an Eigen dynamic matrix to a MATLAB .mat file, specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>)  <a href="#a2f5cc697b513a7f0e5bdab3f357df173">More...</a><br /></td></tr>
<tr class="separator:a2f5cc697b513a7f0e5bdab3f357df173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569c5700863d7054bea8e36f26d9930b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a569c5700863d7054bea8e36f26d9930b">x2contfrac</a> (double x, std::size_t n, std::size_t cut=1e5)</td></tr>
<tr class="memdesc:a569c5700863d7054bea8e36f26d9930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple continued fraction expansion.  <a href="#a569c5700863d7054bea8e36f26d9930b">More...</a><br /></td></tr>
<tr class="separator:a569c5700863d7054bea8e36f26d9930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1511e4d5c07691627c88e66070873b1b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1511e4d5c07691627c88e66070873b1b">contfrac2x</a> (const std::vector&lt; int &gt; &amp;cf, std::size_t n)</td></tr>
<tr class="memdesc:a1511e4d5c07691627c88e66070873b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real representation of a simple continued fraction.  <a href="#a1511e4d5c07691627c88e66070873b1b">More...</a><br /></td></tr>
<tr class="separator:a1511e4d5c07691627c88e66070873b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155296775ac0c0cd0cfe52c2ade8f14c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a155296775ac0c0cd0cfe52c2ade8f14c">contfrac2x</a> (const std::vector&lt; int &gt; &amp;cf)</td></tr>
<tr class="memdesc:a155296775ac0c0cd0cfe52c2ade8f14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real representation of a simple continued fraction.  <a href="#a155296775ac0c0cd0cfe52c2ade8f14c">More...</a><br /></td></tr>
<tr class="separator:a155296775ac0c0cd0cfe52c2ade8f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae245a12a1f7c9ab36da26498b2c4da96"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae245a12a1f7c9ab36da26498b2c4da96">gcd</a> (std::size_t m, std::size_t n)</td></tr>
<tr class="memdesc:ae245a12a1f7c9ab36da26498b2c4da96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest common divisor of two non-negative integers.  <a href="#ae245a12a1f7c9ab36da26498b2c4da96">More...</a><br /></td></tr>
<tr class="separator:ae245a12a1f7c9ab36da26498b2c4da96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b06a1ed3f09f5296470d4c180d9edc"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac6b06a1ed3f09f5296470d4c180d9edc">gcd</a> (const std::vector&lt; std::size_t &gt; &amp;ns)</td></tr>
<tr class="memdesc:ac6b06a1ed3f09f5296470d4c180d9edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest common divisor of a list of non-negative integers.  <a href="#ac6b06a1ed3f09f5296470d4c180d9edc">More...</a><br /></td></tr>
<tr class="separator:ac6b06a1ed3f09f5296470d4c180d9edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ded4330bac75ed34190b1c40d53381"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a37ded4330bac75ed34190b1c40d53381">lcm</a> (std::size_t m, std::size_t n)</td></tr>
<tr class="memdesc:a37ded4330bac75ed34190b1c40d53381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least common multiple of two positive integers.  <a href="#a37ded4330bac75ed34190b1c40d53381">More...</a><br /></td></tr>
<tr class="separator:a37ded4330bac75ed34190b1c40d53381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd094d5bde1344756f98167abb079f5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0cd094d5bde1344756f98167abb079f5">lcm</a> (const std::vector&lt; std::size_t &gt; &amp;ns)</td></tr>
<tr class="memdesc:a0cd094d5bde1344756f98167abb079f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least common multiple of a list of positive integers.  <a href="#a0cd094d5bde1344756f98167abb079f5">More...</a><br /></td></tr>
<tr class="separator:a0cd094d5bde1344756f98167abb079f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2093db36b11503a66f77301fbbedb5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6a2093db36b11503a66f77301fbbedb5">invperm</a> (const std::vector&lt; std::size_t &gt; &amp;perm)</td></tr>
<tr class="memdesc:a6a2093db36b11503a66f77301fbbedb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse permutation.  <a href="#a6a2093db36b11503a66f77301fbbedb5">More...</a><br /></td></tr>
<tr class="separator:a6a2093db36b11503a66f77301fbbedb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ff84d3dba1a25530b8118e1feb39d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac0ff84d3dba1a25530b8118e1feb39d2">compperm</a> (const std::vector&lt; std::size_t &gt; &amp;perm, const std::vector&lt; std::size_t &gt; &amp;sigma)</td></tr>
<tr class="memdesc:ac0ff84d3dba1a25530b8118e1feb39d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose permutations.  <a href="#ac0ff84d3dba1a25530b8118e1feb39d2">More...</a><br /></td></tr>
<tr class="separator:ac0ff84d3dba1a25530b8118e1feb39d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d88751cff72495fccdcfa77b74d1729"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a1d88751cff72495fccdcfa77b74d1729"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1d88751cff72495fccdcfa77b74d1729">applyCTRL</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;ctrl, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a1d88751cff72495fccdcfa77b74d1729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>.  <a href="#a1d88751cff72495fccdcfa77b74d1729">More...</a><br /></td></tr>
<tr class="separator:a1d88751cff72495fccdcfa77b74d1729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcea8c285d9dd3fdedf166266a782ab"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a1dcea8c285d9dd3fdedf166266a782ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1dcea8c285d9dd3fdedf166266a782ab">applyCTRL</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;ctrl, const std::vector&lt; std::size_t &gt; &amp;subsys, std::size_t d=2)</td></tr>
<tr class="memdesc:a1dcea8c285d9dd3fdedf166266a782ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>.  <a href="#a1dcea8c285d9dd3fdedf166266a782ab">More...</a><br /></td></tr>
<tr class="separator:a1dcea8c285d9dd3fdedf166266a782ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f5f4c236713542560dfeb8237c76f7"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a15f5f4c236713542560dfeb8237c76f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a15f5f4c236713542560dfeb8237c76f7">apply</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a15f5f4c236713542560dfeb8237c76f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>.  <a href="#a15f5f4c236713542560dfeb8237c76f7">More...</a><br /></td></tr>
<tr class="separator:a15f5f4c236713542560dfeb8237c76f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a237b102353f57c7243356a82cba36"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a02a237b102353f57c7243356a82cba36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a02a237b102353f57c7243356a82cba36">apply</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, std::size_t d=2)</td></tr>
<tr class="memdesc:a02a237b102353f57c7243356a82cba36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>.  <a href="#a02a237b102353f57c7243356a82cba36">More...</a><br /></td></tr>
<tr class="separator:a02a237b102353f57c7243356a82cba36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d3ed33a419331f7e9721b5fa602e2c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af6d3ed33a419331f7e9721b5fa602e2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af6d3ed33a419331f7e9721b5fa602e2c">channel</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;rho, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:af6d3ed33a419331f7e9721b5fa602e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the density matrix <em>rho</em>.  <a href="#af6d3ed33a419331f7e9721b5fa602e2c">More...</a><br /></td></tr>
<tr class="separator:af6d3ed33a419331f7e9721b5fa602e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8420993c681e0dc2e9ed41bddf109dcd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8420993c681e0dc2e9ed41bddf109dcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8420993c681e0dc2e9ed41bddf109dcd">channel</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;rho, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a8420993c681e0dc2e9ed41bddf109dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part <em>subsys</em> of the multi-partite density matrix <em>rho</em>.  <a href="#a8420993c681e0dc2e9ed41bddf109dcd">More...</a><br /></td></tr>
<tr class="separator:a8420993c681e0dc2e9ed41bddf109dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa64db27df5e0156a53227f0bd932df"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4aa64db27df5e0156a53227f0bd932df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4aa64db27df5e0156a53227f0bd932df">channel</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;rho, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks, const std::vector&lt; std::size_t &gt; &amp;subsys, std::size_t d=2)</td></tr>
<tr class="memdesc:a4aa64db27df5e0156a53227f0bd932df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part <em>subsys</em> of the multi-partite density matrix <em>rho</em>.  <a href="#a4aa64db27df5e0156a53227f0bd932df">More...</a><br /></td></tr>
<tr class="separator:a4aa64db27df5e0156a53227f0bd932df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d1de5e72943a61c35ab634690a841b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a54d1de5e72943a61c35ab634690a841b">super</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a54d1de5e72943a61c35ab634690a841b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superoperator matrix representation.  <a href="#a54d1de5e72943a61c35ab634690a841b">More...</a><br /></td></tr>
<tr class="separator:a54d1de5e72943a61c35ab634690a841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f061a25c22b9d79d2536dc4ea738c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac8f061a25c22b9d79d2536dc4ea738c9">choi</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:ac8f061a25c22b9d79d2536dc4ea738c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choi matrix representation.  <a href="#ac8f061a25c22b9d79d2536dc4ea738c9">More...</a><br /></td></tr>
<tr class="separator:ac8f061a25c22b9d79d2536dc4ea738c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08330f1578fa6b6e382a80132dffb46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac08330f1578fa6b6e382a80132dffb46">choi2kraus</a> (const <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &amp;A)</td></tr>
<tr class="memdesc:ac08330f1578fa6b6e382a80132dffb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts orthogonal Kraus operators from Choi matrix.  <a href="#ac08330f1578fa6b6e382a80132dffb46">More...</a><br /></td></tr>
<tr class="separator:ac08330f1578fa6b6e382a80132dffb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89291882069b2a76650a082029dc4e94"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a89291882069b2a76650a082029dc4e94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a89291882069b2a76650a082029dc4e94">ptrace1</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a89291882069b2a76650a082029dc4e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a89291882069b2a76650a082029dc4e94">More...</a><br /></td></tr>
<tr class="separator:a89291882069b2a76650a082029dc4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae846df6b2525ef728947e00c2074e8b6"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae846df6b2525ef728947e00c2074e8b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae846df6b2525ef728947e00c2074e8b6">ptrace2</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:ae846df6b2525ef728947e00c2074e8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#ae846df6b2525ef728947e00c2074e8b6">More...</a><br /></td></tr>
<tr class="separator:ae846df6b2525ef728947e00c2074e8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fef47d40c93533b586f9b90a97c3621"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5fef47d40c93533b586f9b90a97c3621"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5fef47d40c93533b586f9b90a97c3621">ptrace</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a5fef47d40c93533b586f9b90a97c3621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a5fef47d40c93533b586f9b90a97c3621">More...</a><br /></td></tr>
<tr class="separator:a5fef47d40c93533b586f9b90a97c3621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ee37b4be8fa57500f92a36af347ea4"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a17ee37b4be8fa57500f92a36af347ea4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a17ee37b4be8fa57500f92a36af347ea4">ptrace</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, std::size_t d=2)</td></tr>
<tr class="memdesc:a17ee37b4be8fa57500f92a36af347ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a17ee37b4be8fa57500f92a36af347ea4">More...</a><br /></td></tr>
<tr class="separator:a17ee37b4be8fa57500f92a36af347ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0893a2a4dcfd11696a0e675da03f8f61"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0893a2a4dcfd11696a0e675da03f8f61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0893a2a4dcfd11696a0e675da03f8f61">ptranspose</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a0893a2a4dcfd11696a0e675da03f8f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial transpose.  <a href="#a0893a2a4dcfd11696a0e675da03f8f61">More...</a><br /></td></tr>
<tr class="separator:a0893a2a4dcfd11696a0e675da03f8f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3d03756f80f338c6fdbf6e0cc57679"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afe3d03756f80f338c6fdbf6e0cc57679"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afe3d03756f80f338c6fdbf6e0cc57679">ptranspose</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, std::size_t d=2)</td></tr>
<tr class="memdesc:afe3d03756f80f338c6fdbf6e0cc57679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial transpose.  <a href="#afe3d03756f80f338c6fdbf6e0cc57679">More...</a><br /></td></tr>
<tr class="separator:afe3d03756f80f338c6fdbf6e0cc57679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97cab67fadb870ad19be297b4422ca1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af97cab67fadb870ad19be297b4422ca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af97cab67fadb870ad19be297b4422ca1">syspermute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;perm, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:af97cab67fadb870ad19be297b4422ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">System permutation.  <a href="#af97cab67fadb870ad19be297b4422ca1">More...</a><br /></td></tr>
<tr class="separator:af97cab67fadb870ad19be297b4422ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac813e3344af28cd02b0510f816556857"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac813e3344af28cd02b0510f816556857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac813e3344af28cd02b0510f816556857">syspermute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;perm, std::size_t d=2)</td></tr>
<tr class="memdesc:ac813e3344af28cd02b0510f816556857"><td class="mdescLeft">&#160;</td><td class="mdescRight">System permutation.  <a href="#ac813e3344af28cd02b0510f816556857">More...</a><br /></td></tr>
<tr class="separator:ac813e3344af28cd02b0510f816556857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62c1a613ce4252c37eb12fb5b8f009f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af62c1a613ce4252c37eb12fb5b8f009f"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af62c1a613ce4252c37eb12fb5b8f009f">rand</a> (std::size_t rows, std::size_t cols, double a=0, double b=1)</td></tr>
<tr class="memdesc:af62c1a613ce4252c37eb12fb5b8f009f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random matrix with entries uniformly distributed in the interval [a, b)  <a href="#af62c1a613ce4252c37eb12fb5b8f009f">More...</a><br /></td></tr>
<tr class="separator:af62c1a613ce4252c37eb12fb5b8f009f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef453d90b3165bc013e62bf952e5f84"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6ef453d90b3165bc013e62bf952e5f84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6ef453d90b3165bc013e62bf952e5f84">rand</a> (std::size_t rows, std::size_t cols, double a, double b)</td></tr>
<tr class="memdesc:a6ef453d90b3165bc013e62bf952e5f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real matrix with entries uniformly distributed in the interval [a, b), specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>)  <a href="#a6ef453d90b3165bc013e62bf952e5f84">More...</a><br /></td></tr>
<tr class="separator:a6ef453d90b3165bc013e62bf952e5f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768c04399d0c1cf14fc509bf86a1030e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a768c04399d0c1cf14fc509bf86a1030e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a768c04399d0c1cf14fc509bf86a1030e">rand</a> (std::size_t rows, std::size_t cols, double a, double b)</td></tr>
<tr class="memdesc:a768c04399d0c1cf14fc509bf86a1030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random complex matrix with entries (both real and imaginary) uniformly distributed in the interval [a, b), specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>)  <a href="#a768c04399d0c1cf14fc509bf86a1030e">More...</a><br /></td></tr>
<tr class="separator:a768c04399d0c1cf14fc509bf86a1030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a75700e99974758b39948e65536407"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a98a75700e99974758b39948e65536407">rand</a> (double a=0, double b=1)</td></tr>
<tr class="memdesc:a98a75700e99974758b39948e65536407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real number uniformly distributed in the interval [a, b)  <a href="#a98a75700e99974758b39948e65536407">More...</a><br /></td></tr>
<tr class="separator:a98a75700e99974758b39948e65536407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8b50941df1b415f0b62a2825211f73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aaa8b50941df1b415f0b62a2825211f73">randint</a> (int a=std::numeric_limits&lt; int &gt;::min(), int b=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:aaa8b50941df1b415f0b62a2825211f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random integer (int) uniformly distributed in the interval [a, b].  <a href="#aaa8b50941df1b415f0b62a2825211f73">More...</a><br /></td></tr>
<tr class="separator:aaa8b50941df1b415f0b62a2825211f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5c9d92baf1749ca84aa099e7991bd5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:adb5c9d92baf1749ca84aa099e7991bd5"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#adb5c9d92baf1749ca84aa099e7991bd5">randn</a> (std::size_t rows, std::size_t cols, double mean=0, double sigma=1)</td></tr>
<tr class="memdesc:adb5c9d92baf1749ca84aa099e7991bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random matrix with entries normally distributed in N(mean, sigma)  <a href="#adb5c9d92baf1749ca84aa099e7991bd5">More...</a><br /></td></tr>
<tr class="separator:adb5c9d92baf1749ca84aa099e7991bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351821ffae682d9365179225a46de1ea"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a351821ffae682d9365179225a46de1ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a351821ffae682d9365179225a46de1ea">randn</a> (std::size_t rows, std::size_t cols, double mean, double sigma)</td></tr>
<tr class="memdesc:a351821ffae682d9365179225a46de1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real matrix with entries normally distributed in N(mean, sigma), specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>)  <a href="#a351821ffae682d9365179225a46de1ea">More...</a><br /></td></tr>
<tr class="separator:a351821ffae682d9365179225a46de1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b46bbd2051993d38e7557da12cb47"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a219b46bbd2051993d38e7557da12cb47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a219b46bbd2051993d38e7557da12cb47">randn</a> (std::size_t rows, std::size_t cols, double mean, double sigma)</td></tr>
<tr class="memdesc:a219b46bbd2051993d38e7557da12cb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random complex matrix with entries (both real and imaginary) normally distributed in N(mean, sigma), specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>)  <a href="#a219b46bbd2051993d38e7557da12cb47">More...</a><br /></td></tr>
<tr class="separator:a219b46bbd2051993d38e7557da12cb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab967280114b9e2003bd559c840a5f0e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab967280114b9e2003bd559c840a5f0e6">randn</a> (double mean=0, double sigma=1)</td></tr>
<tr class="memdesc:ab967280114b9e2003bd559c840a5f0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real number (double) normally distributed in N(mean, sigma)  <a href="#ab967280114b9e2003bd559c840a5f0e6">More...</a><br /></td></tr>
<tr class="separator:ab967280114b9e2003bd559c840a5f0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c63023791941918aad0894de4ba1eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5c63023791941918aad0894de4ba1eb7">randU</a> (std::size_t D)</td></tr>
<tr class="memdesc:a5c63023791941918aad0894de4ba1eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random unitary matrix.  <a href="#a5c63023791941918aad0894de4ba1eb7">More...</a><br /></td></tr>
<tr class="separator:a5c63023791941918aad0894de4ba1eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f080960f87046e3b886dcd83f292bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac2f080960f87046e3b886dcd83f292bd">randV</a> (std::size_t Din, std::size_t Dout)</td></tr>
<tr class="memdesc:ac2f080960f87046e3b886dcd83f292bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random isometry matrix.  <a href="#ac2f080960f87046e3b886dcd83f292bd">More...</a><br /></td></tr>
<tr class="separator:ac2f080960f87046e3b886dcd83f292bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a6e123647482a1673a51aa74aa6ca2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad7a6e123647482a1673a51aa74aa6ca2">randkraus</a> (std::size_t N, std::size_t D)</td></tr>
<tr class="memdesc:ad7a6e123647482a1673a51aa74aa6ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of random Kraus operators.  <a href="#ad7a6e123647482a1673a51aa74aa6ca2">More...</a><br /></td></tr>
<tr class="separator:ad7a6e123647482a1673a51aa74aa6ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2a1d87be74a4d0d3cbbca6245417b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5a2a1d87be74a4d0d3cbbca6245417b5">randH</a> (std::size_t D)</td></tr>
<tr class="memdesc:a5a2a1d87be74a4d0d3cbbca6245417b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random Hermitian matrix.  <a href="#a5a2a1d87be74a4d0d3cbbca6245417b5">More...</a><br /></td></tr>
<tr class="separator:a5a2a1d87be74a4d0d3cbbca6245417b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8860e7f282dfd5a75b1292303bd703d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa8860e7f282dfd5a75b1292303bd703d">randket</a> (std::size_t D)</td></tr>
<tr class="memdesc:aa8860e7f282dfd5a75b1292303bd703d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random normalized ket (pure state vector)  <a href="#aa8860e7f282dfd5a75b1292303bd703d">More...</a><br /></td></tr>
<tr class="separator:aa8860e7f282dfd5a75b1292303bd703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5751166c3171415976bd5aab3e5b70f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5751166c3171415976bd5aab3e5b70f5">randrho</a> (std::size_t D)</td></tr>
<tr class="memdesc:a5751166c3171415976bd5aab3e5b70f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random density matrix.  <a href="#a5751166c3171415976bd5aab3e5b70f5">More...</a><br /></td></tr>
<tr class="separator:a5751166c3171415976bd5aab3e5b70f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6375dff8dd558f524bc0e7d3e261100f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6375dff8dd558f524bc0e7d3e261100f">randperm</a> (std::size_t n)</td></tr>
<tr class="memdesc:a6375dff8dd558f524bc0e7d3e261100f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random uniformly distributed permutation.  <a href="#a6375dff8dd558f524bc0e7d3e261100f">More...</a><br /></td></tr>
<tr class="separator:a6375dff8dd558f524bc0e7d3e261100f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a> = 1e-10</td></tr>
<tr class="memdesc:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in <a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d" title="Eigen expression ostream manipulator. ">qpp::disp()</a> and qpp::displn() for setting to zero numbers that have their absolute value smaller than qpp::ct::chop.  <a href="#a3a6d2c509bdcf240869e1bebb3be4e94">More...</a><br /></td></tr>
<tr class="separator:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6">eps</a> = 1e-12</td></tr>
<tr class="memdesc:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to decide whether a number or expression in double precision is zero or not.  <a href="#a9a99ccccd473a9006dfaadb5761ac4f6">More...</a><br /></td></tr>
<tr class="separator:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb5b9cd86de8efebf531f22f673489a"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9cb5b9cd86de8efebf531f22f673489a">maxn</a> = 64</td></tr>
<tr class="memdesc:a9cb5b9cd86de8efebf531f22f673489a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of qubits.  <a href="#a9cb5b9cd86de8efebf531f22f673489a">More...</a><br /></td></tr>
<tr class="separator:a9cb5b9cd86de8efebf531f22f673489a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c04db6f636b236d64fddb069bef492"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a73c04db6f636b236d64fddb069bef492">pi</a> = 3.141592653589793238462643383279502884</td></tr>
<tr class="memdesc:a73c04db6f636b236d64fddb069bef492"><td class="mdescLeft">&#160;</td><td class="mdescRight"><img class="formulaInl" alt="$ \pi $" src="form_5.png"/>  <a href="#a73c04db6f636b236d64fddb069bef492">More...</a><br /></td></tr>
<tr class="separator:a73c04db6f636b236d64fddb069bef492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5c7e10fa94db0755cb937250144630"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aca5c7e10fa94db0755cb937250144630">ee</a> = 2.718281828459045235360287471352662497</td></tr>
<tr class="memdesc:aca5c7e10fa94db0755cb937250144630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base of natural logarithm, <img class="formulaInl" alt="$e$" src="form_6.png"/>.  <a href="#aca5c7e10fa94db0755cb937250144630">More...</a><br /></td></tr>
<tr class="separator:aca5c7e10fa94db0755cb937250144630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b4878f2b40f0dafeb5a437bfd88351"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a33b4878f2b40f0dafeb5a437bfd88351">infty</a> = -1</td></tr>
<tr class="memdesc:a33b4878f2b40f0dafeb5a437bfd88351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to denote infinity.  <a href="#a33b4878f2b40f0dafeb5a437bfd88351">More...</a><br /></td></tr>
<tr class="separator:a33b4878f2b40f0dafeb5a437bfd88351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4969dadb784a76f5182b791fb54198"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classqpp_1_1_init.html">Init</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aca4969dadb784a76f5182b791fb54198">init</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Init::get_instance</a>()</td></tr>
<tr class="memdesc:aca4969dadb784a76f5182b791fb54198"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_init.html" title="const Singleton class that performs additional initializations/cleanups ">qpp::Init</a> const Singleton  <a href="#aca4969dadb784a76f5182b791fb54198">More...</a><br /></td></tr>
<tr class="separator:aca4969dadb784a76f5182b791fb54198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af5132edaed29c8d8233d1bb6ffa47a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classqpp_1_1_codes.html">Codes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3af5132edaed29c8d8233d1bb6ffa47a">codes</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Codes::get_instance</a>()</td></tr>
<tr class="memdesc:a3af5132edaed29c8d8233d1bb6ffa47a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_codes.html" title="const Singleton class that defines quantum error correcting codes ">qpp::Codes</a> const Singleton  <a href="#a3af5132edaed29c8d8233d1bb6ffa47a">More...</a><br /></td></tr>
<tr class="separator:a3af5132edaed29c8d8233d1bb6ffa47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde5be3693c953f79e9c8e262447c8d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classqpp_1_1_gates.html">Gates</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#abde5be3693c953f79e9c8e262447c8d4">gt</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Gates::get_instance</a>()</td></tr>
<tr class="memdesc:abde5be3693c953f79e9c8e262447c8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_gates.html" title="const Singleton class that implements most commonly used gates ">qpp::Gates</a> const Singleton  <a href="#abde5be3693c953f79e9c8e262447c8d4">More...</a><br /></td></tr>
<tr class="separator:abde5be3693c953f79e9c8e262447c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf42bdf7cdbcc98543c7bf6ef36671d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classqpp_1_1_states.html">States</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8cf42bdf7cdbcc98543c7bf6ef36671d">st</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">States::get_instance</a>()</td></tr>
<tr class="memdesc:a8cf42bdf7cdbcc98543c7bf6ef36671d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_states.html" title="const Singleton class that implements most commonly used states ">qpp::States</a> const Singleton  <a href="#a8cf42bdf7cdbcc98543c7bf6ef36671d">More...</a><br /></td></tr>
<tr class="separator:a8cf42bdf7cdbcc98543c7bf6ef36671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae470c1750d1cc895763d1902f3a6882d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1_random_devices.html">RandomDevices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae470c1750d1cc895763d1902f3a6882d">rdevs</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">RandomDevices::get_instance</a>()</td></tr>
<tr class="memdesc:ae470c1750d1cc895763d1902f3a6882d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_random_devices.html" title="Singeleton class that manages the source of randomness in the library. ">qpp::RandomDevices</a> Singleton  <a href="#ae470c1750d1cc895763d1902f3a6882d">More...</a><br /></td></tr>
<tr class="separator:ae470c1750d1cc895763d1902f3a6882d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ad31e93771501f862f00d548105e153b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#ad31e93771501f862f00d548105e153b2">qpp::bra</a> = typedef <a class="el" href="namespaceqpp.html#a7fc6fdb793d3e2fcc393ac909ecb421d">DynRowVect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen row vector. </p>

</div>
</div>
<a class="anchor" id="a8b7b2a88cebcdddfde04c087eecf1328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">qpp::cmat</a> = typedef <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen matrix. </p>

</div>
</div>
<a class="anchor" id="aad7ccc50a6b139279d7b56d07112b183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">qpp::cplx</a> = typedef std::complex&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex number in double precision. </p>

</div>
</div>
<a class="anchor" id="a31d63fc80c90b84ab9ab7062f2d82d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">qpp::dmat</a> = typedef <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real (double precision) dynamic Eigen matrix. </p>

</div>
</div>
<a class="anchor" id="a23060a9e83c7da740a4459153dbd2c41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">qpp::DynColVect</a> = typedef Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen column vector over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// type of colvect is Eigen::Matrix&lt;float, Eigen::Dynamic, 1&gt;</span></div>
<div class="line"><span class="keyword">auto</span> colvect = DynColVect&lt;float&gt;(2);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a39fdcbcd3a12dd426ceab6d4aec4a281"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">qpp::DynMat</a> = typedef Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen matrix over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// type of mat is Eigen::Matrix&lt;float, Eigen::Dynamic, Eigen::Dynamic&gt;</span></div>
<div class="line"><span class="keyword">auto</span> mat = DynMat&lt;float&gt;(2,3);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7fc6fdb793d3e2fcc393ac909ecb421d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a7fc6fdb793d3e2fcc393ac909ecb421d">qpp::DynRowVect</a> = typedef Eigen::Matrix&lt;Scalar, 1, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen row vector over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// type of rowvect is Eigen::Matrix&lt;float, 1, Eigen::Dynamic&gt;</span></div>
<div class="line"><span class="keyword">auto</span> rowvect = DynRowVect&lt;float&gt;(3);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="add021f91288df8af3125cf4b2c8806e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">qpp::ket</a> = typedef <a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen column vector. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3a4cb16d97f9cc763bd133b64f2b6f6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::absm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix absolut value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix absolut value of <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a3e9825a190c56286a68989b67620bbb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::abssq </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolut values squared of a range of complex numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the range's absolut values squared </dd></dl>

</div>
</div>
<a class="anchor" id="a7149763a7b4353138499b349d967303d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::abssq </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolut values squared of a column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the absolut values squared </dd></dl>

</div>
</div>
<a class="anchor" id="ac541afad6657467d9bd83c69345880a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::adjoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Adjoint (Hermitian conjugate) of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ca142339e1a19e0f08488dbc3cf3e71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::anticomm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anti-commutator. </p>
<p>Anti-commutator <img class="formulaInl" alt="$ \{A,B\} = AB + BA $" src="form_31.png"/>. Both <em>A</em> and <em>B</em> must be Eigen expressions over the same scalar field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">B</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Anti-commutator <img class="formulaInl" alt="$AB +BA$" src="form_32.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a15f5f4c236713542560dfeb8237c76f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gate <em>A</em> applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a02a237b102353f57c7243356a82cba36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gate <em>A</em> applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d88751cff72495fccdcfa77b74d1729"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::applyCTRL </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em>. Also, all control subsystems in <em>ctrl</em> must have the same dimension.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">ctrl</td><td>Control subsystem indexes </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CTRL-A gate applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a1dcea8c285d9dd3fdedf166266a782ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::applyCTRL </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of the multi-partite state vector or density matrix <em>state</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">ctrl</td><td>Control subsystem indexes </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CTRL-A gate applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

</div>
</div>
<a class="anchor" id="af6d3ed33a419331f7e9721b5fa602e2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::channel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the density matrix <em>rho</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

</div>
</div>
<a class="anchor" id="a8420993c681e0dc2e9ed41bddf109dcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::channel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part <em>subsys</em> of the multi-partite density matrix <em>rho</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the Kraus operators <em>Ks</em> are applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

</div>
</div>
<a class="anchor" id="a4aa64db27df5e0156a53227f0bd932df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::channel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part <em>subsys</em> of the multi-partite density matrix <em>rho</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the Kraus operators <em>Ks</em> are applied </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f061a25c22b9d79d2536dc4ea738c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::choi </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choi matrix representation. </p>
<p>Constructs the Choi matrix of the channel specified by the set of Kraus operators <em>Ks</em> in the standard operator basis <img class="formulaInl" alt="$\{|i\rangle\langle j|\}$" src="form_15.png"/> ordered in lexicographical order, i.e. <img class="formulaInl" alt="$|0\rangle\langle 0|$" src="form_16.png"/>, <img class="formulaInl" alt="$|0\rangle\langle 1|$" src="form_17.png"/> etc.</p>
<dl class="section note"><dt>Note</dt><dd>The superoperator matrix <img class="formulaInl" alt="$S$" src="form_18.png"/> and the Choi matrix <img class="formulaInl" alt="$ C$" src="form_19.png"/> are related by <img class="formulaInl" alt="$ S_{ab,mn} = C_{ma,nb}$" src="form_20.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Choi matrix representation </dd></dl>

</div>
</div>
<a class="anchor" id="ac08330f1578fa6b6e382a80132dffb46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; qpp::choi2kraus </td>
          <td>(</td>
          <td class="paramtype">const cmat &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts orthogonal Kraus operators from Choi matrix. </p>
<p>Extracts a set of orthogonal (under Hilbert-Schmidt operator norm) Kraus operators from the Choi representation <em>A</em> of the channel</p>
<dl class="section note"><dt>Note</dt><dd>The Kraus operators satisfy <img class="formulaInl" alt="$Tr(K_i^\dagger K_j)=\delta_{ij}$" src="form_35.png"/> for all <img class="formulaInl" alt="$i\neq j$" src="form_36.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Choi matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of Kraus operators </dd></dl>

</div>
</div>
<a class="anchor" id="a9e549f73a22004d7868a2392fcddae5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::comm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commutator. </p>
<p>Commutator <img class="formulaInl" alt="$ [A,B] = AB - BA $" src="form_29.png"/>. Both <em>A</em> and <em>B</em> must be Eigen expressions over the same scalar field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">B</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Commutator <img class="formulaInl" alt="$AB -BA$" src="form_30.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ac0ff84d3dba1a25530b8118e1feb39d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; qpp::compperm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose permutations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
    <tr><td class="paramname">sigma</td><td>Permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Composition of the permutations <em>perm</em> <img class="formulaInl" alt="$\circ$" src="form_34.png"/> <em>sigma</em> = perm(sigma) </dd></dl>

</div>
</div>
<a class="anchor" id="a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::concurrence </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wootters concurrence of the bi-partite qubit mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wootters concurrence </dd></dl>

</div>
</div>
<a class="anchor" id="acbf2df9d3f5c18623eab26ab84ea7418"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::conjugate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex conjugate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex conjugate of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a1511e4d5c07691627c88e66070873b1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::contfrac2x </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real representation of a simple continued fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>Integer vector containing the simple continued fraction expansion </td></tr>
    <tr><td class="paramname">n</td><td>Number of terms considered in the continued fraction expansion. If <em>n</em> is greater than the size of <em>cf</em>,then all terms in <em>cf</em> are considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real representation of the simple continued fraction </dd></dl>

</div>
</div>
<a class="anchor" id="a155296775ac0c0cd0cfe52c2ade8f14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::contfrac2x </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real representation of a simple continued fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>Integer vector containing the simple continued fraction expansion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real representation of the simple continued fraction </dd></dl>

</div>
</div>
<a class="anchor" id="a369c7a2f9f27121178519ddba186fbcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::cosm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix cosine of <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="af68a93794f1719077733b79cc9f2f1df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputScalar , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;OutputScalar&gt; qpp::cwise </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputScalar(*)(const typename Derived::Scalar &amp;)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">f</td><td>Pointer-to-function from scalars of <em>A</em> to <em>OutputScalar</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Component-wise <img class="formulaInl" alt="$f(A)$" src="form_24.png"/>, as a dynamic matrix over the <em>OutputScalar</em> scalar field </dd></dl>

</div>
</div>
<a class="anchor" id="a4f6e426d47b5bf66afc0f7cc0321e0eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::det </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determinant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determinant of <em>A</em>, as a scalar in the same scalar field as <em>A</em>. Returns <img class="formulaInl" alt="$\pm \infty$" src="form_23.png"/> when the determinant overflows/underflows. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f1805e175751ef749374e3c8499f15d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a> qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chop</em> = <code><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen expression ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">chop</td><td>Set to zero the elements smaller in absolute value than <em>chop</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipEigen </dd></dl>

</div>
</div>
<a class="anchor" id="a815b8e5cf5cd3ab4c463bf53eb550dbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a> qpp::disp </td>
          <td>(</td>
          <td class="paramtype">cplx&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chop</em> = <code><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex number ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>Complex number (or any other type implicitly cast-able to std::complex&lt;double&gt;) </td></tr>
    <tr><td class="paramname">chop</td><td>Set to zero the elements smaller in absolute value than <em>chop</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipEigen </dd></dl>

</div>
</div>
<a class="anchor" id="a60298648d39542ac44effa9fe73d41c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a>&lt;InputIterator&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipRange </dd></dl>

</div>
</div>
<a class="anchor" id="afc2ad6985e72b70282708a637cf42e7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a>&lt;typename Container::const_iterator&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard container ostream manipulator. The container must support std::begin(), std::end() and forward iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipRange </dd></dl>

</div>
</div>
<a class="anchor" id="af6e8f13a0bb318a28e1066a8fe5b3ce0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_pointer.html">internal::IOManipPointer</a>&lt;PointerType&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const PointerType *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-style pointer ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the first element </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to be displayed </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipPointer </dd></dl>

</div>
</div>
<a class="anchor" id="a37e461b037fcb585462fa4556d792e45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::entanglement </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entanglement of the bi-partite pure state <em>A</em>. </p>
<p>Defined as the von-Neumann entropy of the reduced density matrix of one of the subsystems </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a3642532b9a23be1c7f7cafa4629e6d5d" title="Shannon/von-Neumann entropy of the probability distribution/density matrix A. ">qpp::shannon()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Entanglement, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a class="anchor" id="a927d85e57656ffb19ddb149985fa52df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt; qpp::evals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvalues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of <em>A</em>, as a complex dynamic column vector </dd></dl>

</div>
</div>
<a class="anchor" id="acc9597bacc39c501eb8e2e5e8530fcd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::evects </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvectors of <em>A</em>, as columns of a complex matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a6855dd77c49ae0b96baf10c12b4bc722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::expm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix exponential of <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a659b50e01fa0b26089d3944c2c56601a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::funm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cplx(*)(const cplx &amp;)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functional calculus f(A) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">f</td><td>Pointer-to-function from complex to complex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em><img class="formulaInl" alt="$f(A)$" src="form_24.png"/></em> </dd></dl>

</div>
</div>
<a class="anchor" id="ae245a12a1f7c9ab36da26498b2c4da96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::gcd </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greatest common divisor of two non-negative integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Non-negative integer </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest common divisor of <em>m</em> and <em>n</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6b06a1ed3f09f5296470d4c180d9edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::gcd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greatest common divisor of a list of non-negative integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>List of non-negative integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest common divisor of all numbers in <em>ns</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a100bf63d3dabba74e049aff37ea7e383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::gconcurrence </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>G-concurrence of the bi-partite pure state <em>A</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Both local dimensions must be equal</dd></dl>
<p>Uses <a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183" title="Logarithm of the determinant. ">qpp::logdet()</a> to avoid overflows </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183" title="Logarithm of the determinant. ">qpp::logdet()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>G-concurrence </dd></dl>

</div>
</div>
<a class="anchor" id="a743da9600f080b2d31951a91b0e2e59a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vs</td><td>std::vector of Eigen expressions as column vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of <em>Vs</em> as columns of a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ad478cc51fbe3e7843460f54eecb0f726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vs</td><td>std::initializer_list of Eigen expressions as column vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of <em>Vs</em> as columns of a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a class="anchor" id="a46120dde34a67d551a3e118f908fdcd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, the input vectors are the columns of <em>A</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of the columns of <em>A</em>, as columns of a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a96eb6e12c5bc0c544663f6705bc1c950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;double&gt; qpp::hevals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hermitian eigenvalues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of Hermitian <em>A</em>, as a real dynamic column vector </dd></dl>

</div>
</div>
<a class="anchor" id="abeadaf6395c78a52339bec119c4a331b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::hevects </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hermitian eigenvectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvectors of Hermitian <em>A</em>, as columns of a complex matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a4ba74531ce09b81f5ea1afbb9c94a6de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::inverse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a2093db36b11503a66f77301fbbedb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; qpp::invperm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the permutation <em>perm</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b2bafdce8302c9ac34ab328ec84a3f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename T::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product. </p>
<p>Used to stop the recursion for the variadic template version of <a class="el" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7" title="Kronecker product. ">qpp::kron()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Its argument <em>head</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a9cf9a3f8918581dc2f6cc4972e22402e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename T::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">tail</td><td>Variadic Eigen expression (zero or more parameters) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all input parameters, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a class="anchor" id="aec55628dde4007629317cfa104b1073f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::vector of Eigen expressions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all elements in <em>As</em>, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ad11c7ebe19908ccaafbf5471f60926c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::initializer_list of Eigen expressions, such as <em>{A1</em>, A2, ... ,Ak} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all elements in <em>As</em>, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

</div>
</div>
<a class="anchor" id="ac695bd8e27cfe03265b550f62c394adb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::kronpow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of <em>A</em> with itself <em>n</em> times <img class="formulaInl" alt="$A^{\otimes n}$" src="form_28.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a37ded4330bac75ed34190b1c40d53381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::lcm </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Least common multiple of two positive integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Positive integer </td></tr>
    <tr><td class="paramname">n</td><td>Positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Least common multiple of <em>m</em> and <em>n</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a0cd094d5bde1344756f98167abb079f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::lcm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Least common multiple of a list of positive integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>List of positive integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Least common multiple of all numbers in <em>ns</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a217e8ae6b09ac3cc89415d4b6204fda6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads Eigen matrix from a binary file (internal format) in double precision. </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided, depending on the scalar field of the matrix that is being loaded.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen dynamic complex matrix from &quot;input.bin&quot;</span></div>
<div class="line"><span class="keyword">auto</span> mat = load&lt;cmat&gt;(<span class="stringliteral">&quot;input.bin&quot;</span>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a84a0f3023e1895d22de4e5f3e727e1dd" title="Loads an Eigen dynamic matrix from a MATLAB .mat file, generic version. ">qpp::loadMATLABmatrix()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">fname</td><td>Output file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84a0f3023e1895d22de4e5f3e727e1dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived qpp::loadMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an Eigen dynamic matrix from a MATLAB .mat file, generic version. </p>
<p>This is the generic version that always throws <em><a class="el" href="classqpp_1_1_exception.html#a91985c96dc408d3538b8f88cf1eaae7ca4e1a1a494e699e494ab9368f62629530">qpp::Exception::Type::UNDEFINED_TYPE</a></em>. It is specialized only for <em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em> and <em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em> (the only matrix types that can be loaded) </p>

</div>
</div>
<a class="anchor" id="aa2030161b0158746beaac80612a3464e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> qpp::loadMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads an Eigen dynamic matrix from a MATLAB .mat file, specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen dynamic double matrix from the</span></div>
<div class="line">MATLAB file <span class="stringliteral">&quot;input.mat&quot;</span></div>
<div class="line"><span class="keyword">auto</span> mat = loadMATLABmatrix&lt;dmat&gt;(<span class="stringliteral">&quot;input.mat&quot;</span>);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If <em>var_name</em> is a complex matrix, only the real part is loaded</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen double dynamic matrix (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </dd></dl>

</div>
</div>
<a class="anchor" id="a26858bfbbec50369d19270c7bf329afa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::loadMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads an Eigen dynamic matrix from a MATLAB .mat file, specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen dynamic complex matrix from the</span></div>
<div class="line">MATLAB file <span class="stringliteral">&quot;input.mat&quot;</span></div>
<div class="line"><span class="keyword">auto</span> mat = loadMATLABmatrix&lt;cmat&gt;(<span class="stringliteral">&quot;input.mat&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be loaded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen complex dynamic matrix (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </dd></dl>

</div>
</div>
<a class="anchor" id="a95a129545b05e69dd7f4c60b009ca183"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::logdet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logarithm of the determinant. </p>
<p>Useful when the determinant overflows/underflows</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logarithm of the determinant of <em>A</em>, as a scalar in the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a683ff6f7df206be1a6105317c4c8ed70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::logm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix logarithm of <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aba8b627b60cfe29f6062776d088cb889"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::lognegativity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logarithmic negativity of the bi-partite mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logarithmic negativity, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a class="anchor" id="aa67d479bd53ef2dafb20db8a2207665c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of all <em>Ks</em> must match the dimension of <em>subsys</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="a3e88cbdbcfb198818f5e49dd7c2904a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of all <em>Ks</em> must match the dimension of <em>subsys</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="a9722c7db968d9d2d73360afe8f4f7cd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of all <em>Ks</em> must match the dimension of <em>subsys</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="ad14e7a9cbe0187ad6577b32a71ed9ce2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state vector or density matrix <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of all <em>Ks</em> must match the dimension of <em>subsys</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="ab5c133827c40b6e615d616442d744cb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cmat &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state <em>A</em> in the orthonormal basis specified by the unitary matrix <em>U</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of <em>U</em> must match the dimension of <em>subsys</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
    <tr><td class="paramname">U</td><td>Unitary matrix whose columns represent the measurement basis vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="a17b170e9f3a5f8822e5ff27f0023cd1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cmat &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the part <em>subsys</em> of the multi-partite state <em>A</em> in the orthonormal basis specified by the unitary matrix <em>U</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of <em>U</em> must match the dimension of <em>subsys</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes that are measured </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
    <tr><td class="paramname">U</td><td>Unitary matrix whose columns represent the measurement basis vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="a9ab9e727227257620aab37cf6e7edabd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="a7cb5b9f74f7d1103c6536307dc7e9e60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="abcf17a94b675f00820fdbc633727c7c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cmat &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> in the orthonormal basis specified by the unitary matrix <em>U</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">U</td><td>Unitary matrix whose columns represent the measurement basis vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple consisiting of the result of the measurement, the vector of outcome probabilities and the vector of post-measurement normalized states </dd></dl>

</div>
</div>
<a class="anchor" id="a94ade48c09bb33df893d7ff62a098374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a> qpp::mket </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-partite qudit ket. </p>
<p>Constructs the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_33.png"/>, where <em>mask</em> is a std::vector of non-negative integers. Each element in <em>mask</em> has to be smaller than the corresponding element in <em>dims</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-partite qudit state vector, as a complex dynamic column vector </dd></dl>

</div>
</div>
<a class="anchor" id="ab7b2d9874a3688fbb56eaff32f9acc7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a> qpp::mket </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-partite qudit ket. </p>
<p>Constructs the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_33.png"/>, all subsystem having equal dimension <em>d</em>. <em>mask</em> is a std::vector of non-negative integers, and each element in <em>mask</em> has to be strictly smaller than <em>d</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-partite qudit state vector, as a complex dynamic column vector </dd></dl>

</div>
</div>
<a class="anchor" id="af881bc85f432ae9ee8a41a34b9ffae07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::mprj </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projector onto multi-partite qudit ket. </p>
<p>Constructs the projector onto the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_33.png"/>, where <em>mask</em> is a std::vector of non-negative integers. Each element in <em>mask</em> has to be smaller than the corresponding element in <em>dims</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto multi-partite qudit state vector, as a complex dynamic matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a933550ccd7424593b89a7682469f3fed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::mprj </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projector onto multi-partite qudit ket. </p>
<p>Constructs the projector onto the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_33.png"/>, all subsystem having equal dimension <em>d</em>. <em>mask</em> is a std::vector of non-negative integers, and each element in <em>mask</em> has to be strictly smaller than <em>d</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto multi-partite qudit state vector, as a complex dynamic matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a19badf6efe78383485b2ba28e4136bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::multiidx2n </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>midx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-index to non-negative integer index. </p>
<p>Uses standard lexicographical order, i.e. 00...0, 00...1 etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">midx</td><td>Multi-index </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative integer index </dd></dl>

</div>
</div>
<a class="anchor" id="afbe051c49a6c9c5a1cbb6401f95143a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; qpp::n2multiidx </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-negative integer index to multi-index. </p>
<p>Uses standard lexicographical order, i.e. 00...0, 00...1 etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Non-negative integer index </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-index of the same size as <em>dims</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5ecdcfef5ce5a89efbebf0f4354be36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::negativity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negativity of the bi-partite mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negativity </dd></dl>

</div>
</div>
<a class="anchor" id="af2e4740854c958579228593dd639aa6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frobenius norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frobenius norm of <em>A</em>, as a real number </dd></dl>

</div>
</div>
<a class="anchor" id="a66175b7225b388d8851c04171fc7a141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; qpp::omega </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>D-th root of unity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>D-th root of unity <img class="formulaInl" alt="$\exp(2\pi i/D)$" src="form_7.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a09fc2700e3012040bfb2f273ea4b79e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::complex&lt;double&gt; qpp::operator&quot;&quot;_i </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_4.png"/> (integer overload) </p>
<p>Example:</p><div class="fragment"><div class="line"><span class="keyword">auto</span> z = 4_i; <span class="comment">// type of z is std::complex&lt;double&gt; </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2a3f80a89a7844c88f5bc556d40c4909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::complex&lt;double&gt; qpp::operator&quot;&quot;_i </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_4.png"/> (real overload) </p>
<p>Example:</p><div class="fragment"><div class="line"><span class="keyword">auto</span> z = 4.5_i; <span class="comment">// type of z is std::complex&lt;double&gt; </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3b4fd08d05e83656e8ce3153fe5a6f0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::powm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix power. </p>
<p>Explicitly multiplies the matrix <em>A</em> with itself <em>n</em> times. By convention <img class="formulaInl" alt="$A^0 = I$" src="form_25.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix power <img class="formulaInl" alt="$A^n$" src="form_27.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a4324f5182395adab0e36eede35e4fe6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::prj </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projector. </p>
<p>Normalized projector onto state vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto the state vector <em>V</em>, or the matrix <em>Zero</em> if <em>V</em> has norm zero (i.e. smaller than <a class="el" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6" title="Used to decide whether a number or expression in double precision is zero or not. ...">qpp::eps</a>), as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a78595ec429a5df51dbe682cdb9711d9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::prod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise product of <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise product of <em>A</em>, as a scalar in the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ab7f10cf7a2845946fedfac88e6a9081f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qpp::prod </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename InputIterator::value_type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise product of a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise product of the range, as a scalar in the same scalar field as the range </dd></dl>

</div>
</div>
<a class="anchor" id="a5fef47d40c93533b586f9b90a97c3621"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<p>Partial trace of the multi-partite density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{subsys}(\cdot)$" src="form_42.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a17ee37b4be8fa57500f92a36af347ea4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<p>Partial trace of the multi-partite density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{subsys}(\cdot)$" src="form_42.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a89291882069b2a76650a082029dc4e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<p>Partial trace of density matrix over the first subsystem in a bi-partite system</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system (must be a std::vector with 2 elements) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{A}(\cdot)$" src="form_37.png"/> over the first subsytem <img class="formulaInl" alt="$A$" src="form_38.png"/> in a bi-partite system <img class="formulaInl" alt="$A\otimes B$" src="form_39.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ae846df6b2525ef728947e00c2074e8b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace2 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system (must be a std::vector with 2 elements) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{B}(\cdot)$" src="form_40.png"/> over the second subsytem <img class="formulaInl" alt="$B$" src="form_41.png"/> in a bi-partite system <img class="formulaInl" alt="$A\otimes B$" src="form_39.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a0893a2a4dcfd11696a0e675da03f8f61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptranspose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial transpose. </p>
<p>Partial transpose of the multi-partite density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial transpose <img class="formulaInl" alt="$(\cdot)^{T_{subsys}}$" src="form_43.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="afe3d03756f80f338c6fdbf6e0cc57679"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptranspose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial transpose. </p>
<p>Partial transpose of the multi-partite density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial transpose <img class="formulaInl" alt="$(\cdot)^{T_{subsys}}$" src="form_43.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a80473c412499e9a120c4597a34add129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::qmutualinfo </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsysA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsysB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantum mutual information between 2 subsystems of a composite system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsysA</td><td>Indexes of the first subsystem </td></tr>
    <tr><td class="paramname">subsysB</td><td>Indexes of the second subsystem </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutual information between the 2 subsystems </dd></dl>

</div>
</div>
<a class="anchor" id="af62c1a613ce4252c37eb12fb5b8f009f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived qpp::rand </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random matrix with entries uniformly distributed in the interval [a, b) </p>
<p>If complex, then both real and imaginary parts are uniformly distributed in [a, b)</p>
<p>This is the generic version that always throws <em><a class="el" href="classqpp_1_1_exception.html#a91985c96dc408d3538b8f88cf1eaae7ca4e1a1a494e699e494ab9368f62629530">qpp::Exception::Type::UNDEFINED_TYPE</a></em>. It is specialized only for <em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em> and <em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em> </p>

</div>
</div>
<a class="anchor" id="a6ef453d90b3165bc013e62bf952e5f84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> qpp::rand </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random real matrix with entries uniformly distributed in the interval [a, b), specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXd,</span></div>
<div class="line"><span class="comment">// with entries uniformly distributed in [-1,1)</span></div>
<div class="line"><span class="keyword">auto</span> mat = rand&lt;dmat&gt;(3, 3, -1, 1);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a768c04399d0c1cf14fc509bf86a1030e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::rand </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random complex matrix with entries (both real and imaginary) uniformly distributed in the interval [a, b), specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXcd,</span></div>
<div class="line"><span class="comment">// with entries (both real and imaginary) uniformly distributed in [-1,1)</span></div>
<div class="line"><span class="keyword">auto</span> mat = rand&lt;cmat&gt;(3, 3, -1, 1);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random complex matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a98a75700e99974758b39948e65536407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::rand </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random real number uniformly distributed in the interval [a, b) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real number (double) uniformly distributed in the interval [a, b) </dd></dl>

</div>
</div>
<a class="anchor" id="a5a2a1d87be74a4d0d3cbbca6245417b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randH </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random Hermitian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random Hermitian matrix </dd></dl>

</div>
</div>
<a class="anchor" id="aaa8b50941df1b415f0b62a2825211f73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int qpp::randint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em> = <code>std::numeric_limits&lt;int&gt;::min()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em> = <code>std::numeric_limits&lt;int&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random integer (int) uniformly distributed in the interval [a, b]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random integer (int) uniformly distributed in the interval [a, b] </dd></dl>

</div>
</div>
<a class="anchor" id="aa8860e7f282dfd5a75b1292303bd703d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a> qpp::randket </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random normalized ket (pure state vector) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random normalized ket </dd></dl>

</div>
</div>
<a class="anchor" id="ad7a6e123647482a1673a51aa74aa6ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; qpp::randkraus </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of random Kraus operators. </p>
<dl class="section note"><dt>Note</dt><dd>The set of Kraus operators satisfy the closure condition <img class="formulaInl" alt="$ \sum_i K_i^\dagger K_i = I$" src="form_21.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Number of Kraus operators </td></tr>
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of <em>N</em> Kraus operators satisfying the closure condition </dd></dl>

</div>
</div>
<a class="anchor" id="adb5c9d92baf1749ca84aa099e7991bd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived qpp::randn </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random matrix with entries normally distributed in N(mean, sigma) </p>
<p>If complex, then both real and imaginary parts are normally distributed in N(mean, sigma)</p>
<p>This is the generic version that always throws <em><a class="el" href="classqpp_1_1_exception.html#a91985c96dc408d3538b8f88cf1eaae7ca4e1a1a494e699e494ab9368f62629530">qpp::Exception::Type::UNDEFINED_TYPE</a></em>. It is specialized only for <em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em> and <em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em> </p>

</div>
</div>
<a class="anchor" id="a351821ffae682d9365179225a46de1ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> qpp::randn </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random real matrix with entries normally distributed in N(mean, sigma), specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXd,</span></div>
<div class="line"><span class="comment">// with entries normally distributed in N(0,2)</span></div>
<div class="line"><span class="keyword">auto</span> mat = randn&lt;dmat&gt;(3, 3, 0, 2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a219b46bbd2051993d38e7557da12cb47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randn </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random complex matrix with entries (both real and imaginary) normally distributed in N(mean, sigma), specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXcd,</span></div>
<div class="line"><span class="comment">// with entries (both real and imaginary) normally distributed in N(0,2)</span></div>
<div class="line"><span class="keyword">auto</span> mat = randn&lt;cmat&gt;(3, 3, 0, 2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random complex matrix </dd></dl>

</div>
</div>
<a class="anchor" id="ab967280114b9e2003bd559c840a5f0e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::randn </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random real number (double) normally distributed in N(mean, sigma) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real number normally distributed in N(mean, sigma) </dd></dl>

</div>
</div>
<a class="anchor" id="a6375dff8dd558f524bc0e7d3e261100f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; qpp::randperm </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random uniformly distributed permutation. </p>
<p>Uses Knuth's shuffle method (as implemented by std::shuffle), so that all permutations are equally probable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Size of the permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random permutation of size <em>n</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a5751166c3171415976bd5aab3e5b70f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randrho </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random density matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random density matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a5c63023791941918aad0894de4ba1eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randU </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random unitary matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random unitary </dd></dl>

</div>
</div>
<a class="anchor" id="ac2f080960f87046e3b886dcd83f292bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randV </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>Din</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>Dout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random isometry matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Din</td><td>Size of the input Hilbert space </td></tr>
    <tr><td class="paramname">Dout</td><td>Size of the output Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random isometry matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a991bc6df4280943452bfbedafa65b9f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::renyi </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy of the probability distribution/density matrix <em>A</em>, for <img class="formulaInl" alt="$ \alpha\geq 0$" src="form_11.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, representing a probability distribution (real dynamic column vector) or a density matrix (complex dynamic matrix) </td></tr>
    <tr><td class="paramname">alpha</td><td>Non-negative real number, use <a class="el" href="namespaceqpp.html#a33b4878f2b40f0dafeb5a437bfd88351" title="Used to denote infinity. ">qpp::infty</a> for <img class="formulaInl" alt="$\alpha = \infty$" src="form_12.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a class="anchor" id="a1f5c91b44c2437627777140980cac940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::reshape </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshape. </p>
<p>Uses column-major order when reshaping (same as MATLAB)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">rows</td><td>Number of rows of the reshaped matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the reshaped matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reshaped matrix with <em>rows</em> rows and <em>cols</em> columns, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a9fae2e6e9a554f4f553524033258021c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;typename Derived::Scalar&gt; qpp::rho2pure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the pure state representation of a matrix proportional to a projector onto a pure state. </p>
<dl class="section note"><dt>Note</dt><dd>No purity check is done, the input state <em>A</em> must have rank one, otherwise the function returs the first non-zero eigenvector of <em>A</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, assumed to be proportional to a projector onto a pure state, i.e. <em>A</em> is assumed to have rank one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique non-zero eigenvector of <em>A</em>, as a dynamic column vector over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a238cf516513837235fbc7d7d283f7b78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qpp::save </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves Eigen expression to a binary file (internal format) in double precision. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a38d10a1f7c02f69d876a28133893d082" title="Saves an Eigen dynamic matrix to a MATLAB .mat file, generic version. ">qpp::saveMATLABmatrix()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">fname</td><td>Output file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38d10a1f7c02f69d876a28133893d082"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qpp::saveMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves an Eigen dynamic matrix to a MATLAB .mat file, generic version. </p>
<p>This is the generic version that always throws <em><a class="el" href="classqpp_1_1_exception.html#a91985c96dc408d3538b8f88cf1eaae7ca4e1a1a494e699e494ab9368f62629530">qpp::Exception::Type::UNDEFINED_TYPE</a></em>. It is specialized only for <em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em> and <em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em> (the only matrix types that can be saved) </p>

</div>
</div>
<a class="anchor" id="a37a40410f15a82495cabcd3641a788cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qpp::saveMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; dmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves an Eigen dynamic matrix to a MATLAB .mat file, specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression over the complex field </td></tr>
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be saved </td></tr>
    <tr><td class="paramname">mode</td><td>Saving mode (append, overwrite etc.), see MATLAB's <em>matOpen()</em> documentation for details </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f5cc697b513a7f0e5bdab3f357df173"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qpp::saveMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves an Eigen dynamic matrix to a MATLAB .mat file, specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression over the complex field </td></tr>
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be saved </td></tr>
    <tr><td class="paramname">mode</td><td>Saving mode (append, overwrite etc.), see MATLAB's <em>matOpen()</em> documentation for details </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8251985eb390022a0116f6572a82ea58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::schatten </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schatten norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">p</td><td>Integer, greater or equal to 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schatten-<em>p</em> norm of <em>A</em>, as a real number </dd></dl>

</div>
</div>
<a class="anchor" id="a810c85eb9d8b64d7b42655713d7c16f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt; qpp::schmidtcoeff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt coefficients of the bi-partite pure state <em>A</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The sum of the squares of the Schmidt coefficients equals 1 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ad23896bc52b516135d0ce545f8149bfc" title="Schmidt probabilities of the bi-partite pure state A. ">qpp::schmidtprob()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schmidt coefficients of <em>A</em>, as a complex dynamic column vector </dd></dl>

</div>
</div>
<a class="anchor" id="ad23896bc52b516135d0ce545f8149bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;double&gt; qpp::schmidtprob </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt probabilities of the bi-partite pure state <em>A</em>. </p>
<p>Defined as the squares of the Schmidt coefficients. The sum of the Schmidt probabilities equals 1. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a810c85eb9d8b64d7b42655713d7c16f3" title="Schmidt coefficients of the bi-partite pure state A. ">qpp::schmidtcoeff()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schmidt probabilites of <em>A</em>, as a real dynamic column vector </dd></dl>

</div>
</div>
<a class="anchor" id="a08b14c1fbfface136d6c42fe28461c3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::schmidtU </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt basis on Alice's side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unitary matrix <img class="formulaInl" alt="$ U $" src="form_8.png"/> whose columns represent the Schmidt basis vectors on Alice's side. </dd></dl>

</div>
</div>
<a class="anchor" id="a015680bd06d6832f6c1e8b314a74339f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::schmidtV </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt basis on Bob's side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unitary matrix <img class="formulaInl" alt="$ V $" src="form_9.png"/> whose columns represent the Schmidt basis vectors on Bob's side. </dd></dl>

</div>
</div>
<a class="anchor" id="a3642532b9a23be1c7f7cafa4629e6d5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::shannon </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shannon/von-Neumann entropy of the probability distribution/density matrix <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, representing a probability distribution (real dynamic column vector) or a density matrix (complex dynamic matrix) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shannon/von-Neumann entropy, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a class="anchor" id="a78be6e812878479d6acbd25cf5ae387c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::sinm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix sin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix sine of <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a62d7f0db6a049f254c2a7a77af8eb29e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::spectralpowm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cplx&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix power. </p>
<p>Uses the spectral decomposition of <em>A</em> to compute the matrix power. By convention <img class="formulaInl" alt="$A^0 = I$" src="form_25.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">z</td><td>Complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix power <img class="formulaInl" alt="$A^z$" src="form_26.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a83e2b23bc11e3cb8dd6909969af7377c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::sqrtm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix square root of <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a48a92e8a327ff86f87c6236965103797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise sum of <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise sum of <em>A</em>, as a scalar in the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a9beed28e8ce824a89484c6aeeb9ea24e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qpp::sum </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename InputIterator::value_type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise sum of a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise sum of the range, as a scalar in the same scalar field as the range </dd></dl>

</div>
</div>
<a class="anchor" id="a54d1de5e72943a61c35ab634690a841b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::super </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Superoperator matrix representation. </p>
<p>Constructs the superoperator matrix of the channel specified by the set of Kraus operators <em>Ks</em> in the standard operator basis <img class="formulaInl" alt="$\{|i\rangle\langle j|\}$" src="form_15.png"/> ordered in lexicographical order, i.e. <img class="formulaInl" alt="$|0\rangle\langle 0|$" src="form_16.png"/>, <img class="formulaInl" alt="$|0\rangle\langle 1|$" src="form_17.png"/> etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Superoperator matrix representation </dd></dl>

</div>
</div>
<a class="anchor" id="a51e1199f56fdc39622a17c949d6ede5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;double&gt; qpp::svals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Singular values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Singular values of <em>A</em>, as a real dynamic column vector </dd></dl>

</div>
</div>
<a class="anchor" id="a33c070beade098fa8f26440791cc8840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::svdU </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left singular vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex dynamic matrix, whose columns are the left singular vectors of <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a285eda1b8ec8614398dd731e5e3a89ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::svdV </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right singular vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex dynamic matrix, whose columns are the right singular vectors of <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="af97cab67fadb870ad19be297b4422ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::syspermute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System permutation. </p>
<p>Permutes the subsystems in a state vector or density matrix. The qubit <em>perm</em>[<em>i</em>] is permuted to the location <em>i</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Permuted system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ac813e3344af28cd02b0510f816556857"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::syspermute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System permutation. </p>
<p>Permutes the subsystems in a state vector or density matrix. The qubit <em>perm</em>[<em>i</em>] is permuted to the location <em>i</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
    <tr><td class="paramname">d</td><td>Subsystem dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Permuted system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a1e1daff5450728504da1fdfedf8d8b54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::trace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trace of <em>A</em>, as a scalar in the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b652e3ea4b9748204359a69588a8c91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::transpose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transpose of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a4980e688af46b3b1a96c2f12c9849cd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::tsallis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tsallis- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy of the probability distribution/density matrix <em>A</em>, for <img class="formulaInl" alt="$ \alpha\geq 0$" src="form_11.png"/>. </p>
<p>When <img class="formulaInl" alt="$ \alpha\to 1$" src="form_13.png"/> the Tsallis entropy converges to the Shannon/von-Neumann entropy, with the logarithm in base <img class="formulaInl" alt="$ e $" src="form_14.png"/></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, representing a probability distribution (real dynamic column vector) or a density matrix (complex dynamic matrix) </td></tr>
    <tr><td class="paramname">alpha</td><td>Non-negative real number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy, with the logarithm in base 2 </dd></dl>

</div>
</div>
<a class="anchor" id="a569c5700863d7054bea8e36f26d9930b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; qpp::x2contfrac </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cut</em> = <code>1e5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple continued fraction expansion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Real number </td></tr>
    <tr><td class="paramname">n</td><td>Number of terms in the expansion </td></tr>
    <tr><td class="paramname">cut</td><td>Stop the expansion when the next term is greater than <em>cut</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer vector containing the simple continued fraction expansion of <em>x</em>. If there are <em>m</em> less than <em>n</em> terms in the expansion, a shorter vector with <em>m</em> components is returned. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a3a6d2c509bdcf240869e1bebb3be4e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::chop = 1e-10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used in <a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d" title="Eigen expression ostream manipulator. ">qpp::disp()</a> and qpp::displn() for setting to zero numbers that have their absolute value smaller than qpp::ct::chop. </p>

</div>
</div>
<a class="anchor" id="a3af5132edaed29c8d8233d1bb6ffa47a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classqpp_1_1_codes.html">Codes</a>&amp; qpp::codes = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Codes::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_codes.html" title="const Singleton class that defines quantum error correcting codes ">qpp::Codes</a> const Singleton </p>
<p>Initializes the codes, see the class <em><a class="el" href="classqpp_1_1_codes.html" title="const Singleton class that defines quantum error correcting codes ">qpp::Codes</a></em> </p>

</div>
</div>
<a class="anchor" id="aca5c7e10fa94db0755cb937250144630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::ee = 2.718281828459045235360287471352662497</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base of natural logarithm, <img class="formulaInl" alt="$e$" src="form_6.png"/>. </p>

</div>
</div>
<a class="anchor" id="a9a99ccccd473a9006dfaadb5761ac4f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::eps = 1e-12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to decide whether a number or expression in double precision is zero or not. </p>
<p>Example:</p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(std::abs(x) &lt; <a class="code" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6">qpp::eps</a>) <span class="comment">// x is zero </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abde5be3693c953f79e9c8e262447c8d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classqpp_1_1_gates.html">Gates</a>&amp; qpp::gt = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Gates::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_gates.html" title="const Singleton class that implements most commonly used gates ">qpp::Gates</a> const Singleton </p>
<p>Initializes the gates, see the class <em><a class="el" href="classqpp_1_1_gates.html" title="const Singleton class that implements most commonly used gates ">qpp::Gates</a></em> </p>

</div>
</div>
<a class="anchor" id="a33b4878f2b40f0dafeb5a437bfd88351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t qpp::infty = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to denote infinity. </p>

</div>
</div>
<a class="anchor" id="aca4969dadb784a76f5182b791fb54198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classqpp_1_1_init.html">Init</a>&amp; qpp::init = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Init::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_init.html" title="const Singleton class that performs additional initializations/cleanups ">qpp::Init</a> const Singleton </p>
<p>Additional initializations/cleanups </p>

</div>
</div>
<a class="anchor" id="a9cb5b9cd86de8efebf531f22f673489a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t qpp::maxn = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of qubits. </p>
<p>Used internally to allocate arrays on the stack (for speed reasons) </p>

</div>
</div>
<a class="anchor" id="a73c04db6f636b236d64fddb069bef492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::pi = 3.141592653589793238462643383279502884</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><img class="formulaInl" alt="$ \pi $" src="form_5.png"/> </p>

</div>
</div>
<a class="anchor" id="ae470c1750d1cc895763d1902f3a6882d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1_random_devices.html">RandomDevices</a>&amp; qpp::rdevs = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">RandomDevices::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_random_devices.html" title="Singeleton class that manages the source of randomness in the library. ">qpp::RandomDevices</a> Singleton </p>
<p>Initializes the random devices, see the class <em><a class="el" href="classqpp_1_1_random_devices.html" title="Singeleton class that manages the source of randomness in the library. ">qpp::RandomDevices</a></em> </p>

</div>
</div>
<a class="anchor" id="a8cf42bdf7cdbcc98543c7bf6ef36671d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classqpp_1_1_states.html">States</a>&amp; qpp::st = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">States::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_states.html" title="const Singleton class that implements most commonly used states ">qpp::States</a> const Singleton </p>
<p>Initializes the states, see the class <em><a class="el" href="classqpp_1_1_states.html" title="const Singleton class that implements most commonly used states ">qpp::States</a></em> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceqpp.html">qpp</a></li>
    <li class="footer">Generated on Thu Nov 13 2014 17:03:07 for quantum++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
