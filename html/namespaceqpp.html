<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>quantum++: qpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">quantum++
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A C++11 quantum computing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceqpp.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">qpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceqpp_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceqpp_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_codes.html">Codes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that defines quantum error correcting codes  <a href="classqpp_1_1_codes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates custom exceptions, used when validating function parameters.  <a href="classqpp_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_gates.html">Gates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that implements most commonly used gates  <a href="classqpp_1_1_gates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_init.html">Init</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that performs additional initializations/cleanups  <a href="classqpp_1_1_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_random_devices.html">RandomDevices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singeleton class that manages the source of randomness in the library.  <a href="classqpp_1_1_random_devices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_states.html">States</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const Singleton class that implements most commonly used states  <a href="classqpp_1_1_states.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqpp_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures time.  <a href="classqpp_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aad7ccc50a6b139279d7b56d07112b183"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> = std::complex&lt; double &gt;</td></tr>
<tr class="memdesc:aad7ccc50a6b139279d7b56d07112b183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number in double precision.  <a href="#aad7ccc50a6b139279d7b56d07112b183">More...</a><br /></td></tr>
<tr class="separator:aad7ccc50a6b139279d7b56d07112b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fdcbcd3a12dd426ceab6d4aec4a281"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a39fdcbcd3a12dd426ceab6d4aec4a281"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a39fdcbcd3a12dd426ceab6d4aec4a281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen matrix over the field specified by <em>Scalar</em>.  <a href="#a39fdcbcd3a12dd426ceab6d4aec4a281">More...</a><br /></td></tr>
<tr class="separator:a39fdcbcd3a12dd426ceab6d4aec4a281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23060a9e83c7da740a4459153dbd2c41"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a23060a9e83c7da740a4459153dbd2c41"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a23060a9e83c7da740a4459153dbd2c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen column vector over the field specified by <em>Scalar</em>.  <a href="#a23060a9e83c7da740a4459153dbd2c41">More...</a><br /></td></tr>
<tr class="separator:a23060a9e83c7da740a4459153dbd2c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc6fdb793d3e2fcc393ac909ecb421d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a7fc6fdb793d3e2fcc393ac909ecb421d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7fc6fdb793d3e2fcc393ac909ecb421d">DynRowVect</a> = Eigen::Matrix&lt; Scalar, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a7fc6fdb793d3e2fcc393ac909ecb421d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Eigen row vector over the field specified by <em>Scalar</em>.  <a href="#a7fc6fdb793d3e2fcc393ac909ecb421d">More...</a><br /></td></tr>
<tr class="separator:a7fc6fdb793d3e2fcc393ac909ecb421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add021f91288df8af3125cf4b2c8806e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a> = <a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;</td></tr>
<tr class="memdesc:add021f91288df8af3125cf4b2c8806e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen column vector.  <a href="#add021f91288df8af3125cf4b2c8806e6">More...</a><br /></td></tr>
<tr class="separator:add021f91288df8af3125cf4b2c8806e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31e93771501f862f00d548105e153b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad31e93771501f862f00d548105e153b2">bra</a> = <a class="el" href="namespaceqpp.html#a7fc6fdb793d3e2fcc393ac909ecb421d">DynRowVect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;</td></tr>
<tr class="memdesc:ad31e93771501f862f00d548105e153b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen row vector.  <a href="#ad31e93771501f862f00d548105e153b2">More...</a><br /></td></tr>
<tr class="separator:ad31e93771501f862f00d548105e153b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7b2a88cebcdddfde04c087eecf1328"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> = <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;</td></tr>
<tr class="memdesc:a8b7b2a88cebcdddfde04c087eecf1328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex (double precision) dynamic Eigen matrix.  <a href="#a8b7b2a88cebcdddfde04c087eecf1328">More...</a><br /></td></tr>
<tr class="separator:a8b7b2a88cebcdddfde04c087eecf1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d63fc80c90b84ab9ab7062f2d82d86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> = <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; double &gt;</td></tr>
<tr class="memdesc:a31d63fc80c90b84ab9ab7062f2d82d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real (double precision) dynamic Eigen matrix.  <a href="#a31d63fc80c90b84ab9ab7062f2d82d86">More...</a><br /></td></tr>
<tr class="separator:a31d63fc80c90b84ab9ab7062f2d82d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a09fc2700e3012040bfb2f273ea4b79e9"><td class="memItemLeft" align="right" valign="top">constexpr std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a09fc2700e3012040bfb2f273ea4b79e9">operator&quot;&quot;_i</a> (unsigned long long int x)</td></tr>
<tr class="memdesc:a09fc2700e3012040bfb2f273ea4b79e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_4.png"/> (integer overload)  <a href="#a09fc2700e3012040bfb2f273ea4b79e9">More...</a><br /></td></tr>
<tr class="separator:a09fc2700e3012040bfb2f273ea4b79e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3f80a89a7844c88f5bc556d40c4909"><td class="memItemLeft" align="right" valign="top">constexpr std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2a3f80a89a7844c88f5bc556d40c4909">operator&quot;&quot;_i</a> (long double x)</td></tr>
<tr class="memdesc:a2a3f80a89a7844c88f5bc556d40c4909"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_4.png"/> (real overload)  <a href="#a2a3f80a89a7844c88f5bc556d40c4909">More...</a><br /></td></tr>
<tr class="separator:a2a3f80a89a7844c88f5bc556d40c4909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66175b7225b388d8851c04171fc7a141"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a66175b7225b388d8851c04171fc7a141">omega</a> (std::size_t D)</td></tr>
<tr class="memdesc:a66175b7225b388d8851c04171fc7a141"><td class="mdescLeft">&#160;</td><td class="mdescRight">D-th root of unity.  <a href="#a66175b7225b388d8851c04171fc7a141">More...</a><br /></td></tr>
<tr class="separator:a66175b7225b388d8851c04171fc7a141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810c85eb9d8b64d7b42655713d7c16f3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a810c85eb9d8b64d7b42655713d7c16f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a810c85eb9d8b64d7b42655713d7c16f3">schmidtcoeff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a810c85eb9d8b64d7b42655713d7c16f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt coefficients of the bi-partite pure state <em>A</em>.  <a href="#a810c85eb9d8b64d7b42655713d7c16f3">More...</a><br /></td></tr>
<tr class="separator:a810c85eb9d8b64d7b42655713d7c16f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b14c1fbfface136d6c42fe28461c3a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a08b14c1fbfface136d6c42fe28461c3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a08b14c1fbfface136d6c42fe28461c3a">schmidtU</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a08b14c1fbfface136d6c42fe28461c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt basis on Alice's side.  <a href="#a08b14c1fbfface136d6c42fe28461c3a">More...</a><br /></td></tr>
<tr class="separator:a08b14c1fbfface136d6c42fe28461c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015680bd06d6832f6c1e8b314a74339f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a015680bd06d6832f6c1e8b314a74339f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a015680bd06d6832f6c1e8b314a74339f">schmidtV</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a015680bd06d6832f6c1e8b314a74339f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt basis on Bob's side.  <a href="#a015680bd06d6832f6c1e8b314a74339f">More...</a><br /></td></tr>
<tr class="separator:a015680bd06d6832f6c1e8b314a74339f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23896bc52b516135d0ce545f8149bfc"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad23896bc52b516135d0ce545f8149bfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad23896bc52b516135d0ce545f8149bfc">schmidtprob</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:ad23896bc52b516135d0ce545f8149bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schmidt probabilities of the bi-partite pure state <em>A</em>.  <a href="#ad23896bc52b516135d0ce545f8149bfc">More...</a><br /></td></tr>
<tr class="separator:ad23896bc52b516135d0ce545f8149bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e461b037fcb585462fa4556d792e45"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a37e461b037fcb585462fa4556d792e45"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a37e461b037fcb585462fa4556d792e45">entanglement</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a37e461b037fcb585462fa4556d792e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entanglement of the bi-partite pure state <em>A</em>.  <a href="#a37e461b037fcb585462fa4556d792e45">More...</a><br /></td></tr>
<tr class="separator:a37e461b037fcb585462fa4556d792e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100bf63d3dabba74e049aff37ea7e383"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a100bf63d3dabba74e049aff37ea7e383"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a100bf63d3dabba74e049aff37ea7e383">gconcurrence</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a100bf63d3dabba74e049aff37ea7e383"><td class="mdescLeft">&#160;</td><td class="mdescRight">G-concurrence of the bi-partite pure state <em>A</em>.  <a href="#a100bf63d3dabba74e049aff37ea7e383">More...</a><br /></td></tr>
<tr class="separator:a100bf63d3dabba74e049aff37ea7e383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ecdcfef5ce5a89efbebf0f4354be36"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae5ecdcfef5ce5a89efbebf0f4354be36"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae5ecdcfef5ce5a89efbebf0f4354be36">negativity</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:ae5ecdcfef5ce5a89efbebf0f4354be36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negativity of the bi-partite mixed state <em>A</em>.  <a href="#ae5ecdcfef5ce5a89efbebf0f4354be36">More...</a><br /></td></tr>
<tr class="separator:ae5ecdcfef5ce5a89efbebf0f4354be36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8b627b60cfe29f6062776d088cb889"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aba8b627b60cfe29f6062776d088cb889"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aba8b627b60cfe29f6062776d088cb889">lognegativity</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:aba8b627b60cfe29f6062776d088cb889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithmic negativity of the bi-partite mixed state <em>A</em>.  <a href="#aba8b627b60cfe29f6062776d088cb889">More...</a><br /></td></tr>
<tr class="separator:aba8b627b60cfe29f6062776d088cb889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b">concurrence</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wootters concurrence of the bi-partite qubit mixed state <em>A</em>.  <a href="#a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b">More...</a><br /></td></tr>
<tr class="separator:a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3642532b9a23be1c7f7cafa4629e6d5d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3642532b9a23be1c7f7cafa4629e6d5d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3642532b9a23be1c7f7cafa4629e6d5d">shannon</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a3642532b9a23be1c7f7cafa4629e6d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shannon/von-Neumann entropy of the probability distribution/density matrix <em>A</em>.  <a href="#a3642532b9a23be1c7f7cafa4629e6d5d">More...</a><br /></td></tr>
<tr class="separator:a3642532b9a23be1c7f7cafa4629e6d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991bc6df4280943452bfbedafa65b9f7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a991bc6df4280943452bfbedafa65b9f7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a991bc6df4280943452bfbedafa65b9f7">renyi</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double alpha)</td></tr>
<tr class="memdesc:a991bc6df4280943452bfbedafa65b9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renyi- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy of the probability distribution/density matrix <em>A</em>, for <img class="formulaInl" alt="$ \alpha\geq 0$" src="form_11.png"/>.  <a href="#a991bc6df4280943452bfbedafa65b9f7">More...</a><br /></td></tr>
<tr class="separator:a991bc6df4280943452bfbedafa65b9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4980e688af46b3b1a96c2f12c9849cd0"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4980e688af46b3b1a96c2f12c9849cd0"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4980e688af46b3b1a96c2f12c9849cd0">tsallis</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double alpha)</td></tr>
<tr class="memdesc:a4980e688af46b3b1a96c2f12c9849cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tsallis- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy of the probability distribution/density matrix <em>A</em>, for <img class="formulaInl" alt="$ \alpha\geq 0$" src="form_11.png"/><br />
.  <a href="#a4980e688af46b3b1a96c2f12c9849cd0">More...</a><br /></td></tr>
<tr class="separator:a4980e688af46b3b1a96c2f12c9849cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80473c412499e9a120c4597a34add129"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a80473c412499e9a120c4597a34add129"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a80473c412499e9a120c4597a34add129">qmutualinfo</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsysA, const std::vector&lt; std::size_t &gt; &amp;subsysB, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a80473c412499e9a120c4597a34add129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantum mutual information between 2 subsystems of a composite system.  <a href="#a80473c412499e9a120c4597a34add129">More...</a><br /></td></tr>
<tr class="separator:a80473c412499e9a120c4597a34add129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b652e3ea4b9748204359a69588a8c91"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7b652e3ea4b9748204359a69588a8c91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7b652e3ea4b9748204359a69588a8c91">transpose</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a7b652e3ea4b9748204359a69588a8c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose.  <a href="#a7b652e3ea4b9748204359a69588a8c91">More...</a><br /></td></tr>
<tr class="separator:a7b652e3ea4b9748204359a69588a8c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf2df9d3f5c18623eab26ab84ea7418"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acbf2df9d3f5c18623eab26ab84ea7418"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#acbf2df9d3f5c18623eab26ab84ea7418">conjugate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:acbf2df9d3f5c18623eab26ab84ea7418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate.  <a href="#acbf2df9d3f5c18623eab26ab84ea7418">More...</a><br /></td></tr>
<tr class="separator:acbf2df9d3f5c18623eab26ab84ea7418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac541afad6657467d9bd83c69345880a2"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac541afad6657467d9bd83c69345880a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2">adjoint</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:ac541afad6657467d9bd83c69345880a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjoint.  <a href="#ac541afad6657467d9bd83c69345880a2">More...</a><br /></td></tr>
<tr class="separator:ac541afad6657467d9bd83c69345880a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba74531ce09b81f5ea1afbb9c94a6de"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4ba74531ce09b81f5ea1afbb9c94a6de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4ba74531ce09b81f5ea1afbb9c94a6de">inverse</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a4ba74531ce09b81f5ea1afbb9c94a6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse.  <a href="#a4ba74531ce09b81f5ea1afbb9c94a6de">More...</a><br /></td></tr>
<tr class="separator:a4ba74531ce09b81f5ea1afbb9c94a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1daff5450728504da1fdfedf8d8b54"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1e1daff5450728504da1fdfedf8d8b54"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54">trace</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a1e1daff5450728504da1fdfedf8d8b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace.  <a href="#a1e1daff5450728504da1fdfedf8d8b54">More...</a><br /></td></tr>
<tr class="separator:a1e1daff5450728504da1fdfedf8d8b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4f6e426d47b5bf66afc0f7cc0321e0eb">det</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determinant.  <a href="#a4f6e426d47b5bf66afc0f7cc0321e0eb">More...</a><br /></td></tr>
<tr class="separator:a4f6e426d47b5bf66afc0f7cc0321e0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a129545b05e69dd7f4c60b009ca183"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a95a129545b05e69dd7f4c60b009ca183"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183">logdet</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a95a129545b05e69dd7f4c60b009ca183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithm of the determinant.  <a href="#a95a129545b05e69dd7f4c60b009ca183">More...</a><br /></td></tr>
<tr class="separator:a95a129545b05e69dd7f4c60b009ca183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a92e8a327ff86f87c6236965103797"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a48a92e8a327ff86f87c6236965103797"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a48a92e8a327ff86f87c6236965103797">sum</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a48a92e8a327ff86f87c6236965103797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum of <em>A</em>.  <a href="#a48a92e8a327ff86f87c6236965103797">More...</a><br /></td></tr>
<tr class="separator:a48a92e8a327ff86f87c6236965103797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78595ec429a5df51dbe682cdb9711d9c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a78595ec429a5df51dbe682cdb9711d9c"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a78595ec429a5df51dbe682cdb9711d9c">prod</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a78595ec429a5df51dbe682cdb9711d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise product of <em>A</em>.  <a href="#a78595ec429a5df51dbe682cdb9711d9c">More...</a><br /></td></tr>
<tr class="separator:a78595ec429a5df51dbe682cdb9711d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e4740854c958579228593dd639aa6c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af2e4740854c958579228593dd639aa6c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af2e4740854c958579228593dd639aa6c">norm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:af2e4740854c958579228593dd639aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frobenius norm.  <a href="#af2e4740854c958579228593dd639aa6c">More...</a><br /></td></tr>
<tr class="separator:af2e4740854c958579228593dd639aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927d85e57656ffb19ddb149985fa52df"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a927d85e57656ffb19ddb149985fa52df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df">evals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a927d85e57656ffb19ddb149985fa52df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalues.  <a href="#a927d85e57656ffb19ddb149985fa52df">More...</a><br /></td></tr>
<tr class="separator:a927d85e57656ffb19ddb149985fa52df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8">evects</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvectors.  <a href="#acc9597bacc39c501eb8e2e5e8530fcd8">More...</a><br /></td></tr>
<tr class="separator:acc9597bacc39c501eb8e2e5e8530fcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96eb6e12c5bc0c544663f6705bc1c950"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a96eb6e12c5bc0c544663f6705bc1c950"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a96eb6e12c5bc0c544663f6705bc1c950">hevals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a96eb6e12c5bc0c544663f6705bc1c950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian eigenvalues.  <a href="#a96eb6e12c5bc0c544663f6705bc1c950">More...</a><br /></td></tr>
<tr class="separator:a96eb6e12c5bc0c544663f6705bc1c950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeadaf6395c78a52339bec119c4a331b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:abeadaf6395c78a52339bec119c4a331b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#abeadaf6395c78a52339bec119c4a331b">hevects</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:abeadaf6395c78a52339bec119c4a331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hermitian eigenvectors.  <a href="#abeadaf6395c78a52339bec119c4a331b">More...</a><br /></td></tr>
<tr class="separator:abeadaf6395c78a52339bec119c4a331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e1199f56fdc39622a17c949d6ede5a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a51e1199f56fdc39622a17c949d6ede5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a51e1199f56fdc39622a17c949d6ede5a">svals</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a51e1199f56fdc39622a17c949d6ede5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular values.  <a href="#a51e1199f56fdc39622a17c949d6ede5a">More...</a><br /></td></tr>
<tr class="separator:a51e1199f56fdc39622a17c949d6ede5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c070beade098fa8f26440791cc8840"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a33c070beade098fa8f26440791cc8840"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a33c070beade098fa8f26440791cc8840">svdU</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a33c070beade098fa8f26440791cc8840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left singular vectors.  <a href="#a33c070beade098fa8f26440791cc8840">More...</a><br /></td></tr>
<tr class="separator:a33c070beade098fa8f26440791cc8840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a285eda1b8ec8614398dd731e5e3a89ed">svdV</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a285eda1b8ec8614398dd731e5e3a89ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right singular vectors.  <a href="#a285eda1b8ec8614398dd731e5e3a89ed">More...</a><br /></td></tr>
<tr class="separator:a285eda1b8ec8614398dd731e5e3a89ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659b50e01fa0b26089d3944c2c56601a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a659b50e01fa0b26089d3944c2c56601a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a">funm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>(*f)(const <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> &amp;))</td></tr>
<tr class="memdesc:a659b50e01fa0b26089d3944c2c56601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional calculus f(A)  <a href="#a659b50e01fa0b26089d3944c2c56601a">More...</a><br /></td></tr>
<tr class="separator:a659b50e01fa0b26089d3944c2c56601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a83e2b23bc11e3cb8dd6909969af7377c">sqrtm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a83e2b23bc11e3cb8dd6909969af7377c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix square root.  <a href="#a83e2b23bc11e3cb8dd6909969af7377c">More...</a><br /></td></tr>
<tr class="separator:a83e2b23bc11e3cb8dd6909969af7377c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3a4cb16d97f9cc763bd133b64f2b6f6d">absm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix absolut value.  <a href="#a3a4cb16d97f9cc763bd133b64f2b6f6d">More...</a><br /></td></tr>
<tr class="separator:a3a4cb16d97f9cc763bd133b64f2b6f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6855dd77c49ae0b96baf10c12b4bc722">expm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a6855dd77c49ae0b96baf10c12b4bc722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix exponential.  <a href="#a6855dd77c49ae0b96baf10c12b4bc722">More...</a><br /></td></tr>
<tr class="separator:a6855dd77c49ae0b96baf10c12b4bc722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683ff6f7df206be1a6105317c4c8ed70"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a683ff6f7df206be1a6105317c4c8ed70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a683ff6f7df206be1a6105317c4c8ed70">logm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a683ff6f7df206be1a6105317c4c8ed70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix logarithm.  <a href="#a683ff6f7df206be1a6105317c4c8ed70">More...</a><br /></td></tr>
<tr class="separator:a683ff6f7df206be1a6105317c4c8ed70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be6e812878479d6acbd25cf5ae387c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a78be6e812878479d6acbd25cf5ae387c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a78be6e812878479d6acbd25cf5ae387c">sinm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a78be6e812878479d6acbd25cf5ae387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix sin.  <a href="#a78be6e812878479d6acbd25cf5ae387c">More...</a><br /></td></tr>
<tr class="separator:a78be6e812878479d6acbd25cf5ae387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c7a2f9f27121178519ddba186fbcd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a369c7a2f9f27121178519ddba186fbcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a369c7a2f9f27121178519ddba186fbcd">cosm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a369c7a2f9f27121178519ddba186fbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix cos.  <a href="#a369c7a2f9f27121178519ddba186fbcd">More...</a><br /></td></tr>
<tr class="separator:a369c7a2f9f27121178519ddba186fbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a62d7f0db6a049f254c2a7a77af8eb29e">spectralpowm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> z)</td></tr>
<tr class="memdesc:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix power.  <a href="#a62d7f0db6a049f254c2a7a77af8eb29e">More...</a><br /></td></tr>
<tr class="separator:a62d7f0db6a049f254c2a7a77af8eb29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4fd08d05e83656e8ce3153fe5a6f0b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3b4fd08d05e83656e8ce3153fe5a6f0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b">powm</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::size_t n)</td></tr>
<tr class="memdesc:a3b4fd08d05e83656e8ce3153fe5a6f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix power.  <a href="#a3b4fd08d05e83656e8ce3153fe5a6f0b">More...</a><br /></td></tr>
<tr class="separator:a3b4fd08d05e83656e8ce3153fe5a6f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8251985eb390022a0116f6572a82ea58"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8251985eb390022a0116f6572a82ea58"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8251985eb390022a0116f6572a82ea58">schatten</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::size_t p)</td></tr>
<tr class="memdesc:a8251985eb390022a0116f6572a82ea58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schatten norm.  <a href="#a8251985eb390022a0116f6572a82ea58">More...</a><br /></td></tr>
<tr class="separator:a8251985eb390022a0116f6572a82ea58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68a93794f1719077733b79cc9f2f1df"><td class="memTemplParams" colspan="2">template&lt;typename OutputScalar , typename Derived &gt; </td></tr>
<tr class="memitem:af68a93794f1719077733b79cc9f2f1df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; OutputScalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af68a93794f1719077733b79cc9f2f1df">cwise</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, OutputScalar(*f)(const typename Derived::Scalar &amp;))</td></tr>
<tr class="memdesc:af68a93794f1719077733b79cc9f2f1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor.  <a href="#af68a93794f1719077733b79cc9f2f1df">More...</a><br /></td></tr>
<tr class="separator:af68a93794f1719077733b79cc9f2f1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2bafdce8302c9ac34ab328ec84a3f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b2bafdce8302c9ac34ab328ec84a3f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename T::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7">kron</a> (const T &amp;head)</td></tr>
<tr class="memdesc:a3b2bafdce8302c9ac34ab328ec84a3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product (variadic overload)  <a href="#a3b2bafdce8302c9ac34ab328ec84a3f7">More...</a><br /></td></tr>
<tr class="separator:a3b2bafdce8302c9ac34ab328ec84a3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf9a3f8918581dc2f6cc4972e22402e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9cf9a3f8918581dc2f6cc4972e22402e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename T::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9cf9a3f8918581dc2f6cc4972e22402e">kron</a> (const T &amp;head, const Args &amp;...tail)</td></tr>
<tr class="memdesc:a9cf9a3f8918581dc2f6cc4972e22402e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product (variadic overload)  <a href="#a9cf9a3f8918581dc2f6cc4972e22402e">More...</a><br /></td></tr>
<tr class="separator:a9cf9a3f8918581dc2f6cc4972e22402e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec55628dde4007629317cfa104b1073f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aec55628dde4007629317cfa104b1073f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aec55628dde4007629317cfa104b1073f">kron</a> (const std::vector&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:aec55628dde4007629317cfa104b1073f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product (std::vector overload)  <a href="#aec55628dde4007629317cfa104b1073f">More...</a><br /></td></tr>
<tr class="separator:aec55628dde4007629317cfa104b1073f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c7ebe19908ccaafbf5471f60926c7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad11c7ebe19908ccaafbf5471f60926c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad11c7ebe19908ccaafbf5471f60926c7">kron</a> (const std::initializer_list&lt; Derived &gt; &amp;As)</td></tr>
<tr class="memdesc:ad11c7ebe19908ccaafbf5471f60926c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker product (std::initializer_list overload)  <a href="#ad11c7ebe19908ccaafbf5471f60926c7">More...</a><br /></td></tr>
<tr class="separator:ad11c7ebe19908ccaafbf5471f60926c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac695bd8e27cfe03265b550f62c394adb"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac695bd8e27cfe03265b550f62c394adb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac695bd8e27cfe03265b550f62c394adb">kronpow</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::size_t n)</td></tr>
<tr class="memdesc:ac695bd8e27cfe03265b550f62c394adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker power.  <a href="#ac695bd8e27cfe03265b550f62c394adb">More...</a><br /></td></tr>
<tr class="separator:ac695bd8e27cfe03265b550f62c394adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5c91b44c2437627777140980cac940"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1f5c91b44c2437627777140980cac940"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940">reshape</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, std::size_t rows, std::size_t cols)</td></tr>
<tr class="memdesc:a1f5c91b44c2437627777140980cac940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape.  <a href="#a1f5c91b44c2437627777140980cac940">More...</a><br /></td></tr>
<tr class="separator:a1f5c91b44c2437627777140980cac940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e549f73a22004d7868a2392fcddae5f"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a9e549f73a22004d7868a2392fcddae5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9e549f73a22004d7868a2392fcddae5f">comm</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;B)</td></tr>
<tr class="memdesc:a9e549f73a22004d7868a2392fcddae5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commutator.  <a href="#a9e549f73a22004d7868a2392fcddae5f">More...</a><br /></td></tr>
<tr class="separator:a9e549f73a22004d7868a2392fcddae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca142339e1a19e0f08488dbc3cf3e71"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a0ca142339e1a19e0f08488dbc3cf3e71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0ca142339e1a19e0f08488dbc3cf3e71">anticomm</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;A, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;B)</td></tr>
<tr class="memdesc:a0ca142339e1a19e0f08488dbc3cf3e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anti-commutator.  <a href="#a0ca142339e1a19e0f08488dbc3cf3e71">More...</a><br /></td></tr>
<tr class="separator:a0ca142339e1a19e0f08488dbc3cf3e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4324f5182395adab0e36eede35e4fe6b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4324f5182395adab0e36eede35e4fe6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4324f5182395adab0e36eede35e4fe6b">prj</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;V)</td></tr>
<tr class="memdesc:a4324f5182395adab0e36eede35e4fe6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector.  <a href="#a4324f5182395adab0e36eede35e4fe6b">More...</a><br /></td></tr>
<tr class="separator:a4324f5182395adab0e36eede35e4fe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743da9600f080b2d31951a91b0e2e59a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a743da9600f080b2d31951a91b0e2e59a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a743da9600f080b2d31951a91b0e2e59a">grams</a> (const std::vector&lt; Derived &gt; &amp;Vs)</td></tr>
<tr class="memdesc:a743da9600f080b2d31951a91b0e2e59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization (std::vector overload)  <a href="#a743da9600f080b2d31951a91b0e2e59a">More...</a><br /></td></tr>
<tr class="separator:a743da9600f080b2d31951a91b0e2e59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad478cc51fbe3e7843460f54eecb0f726"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad478cc51fbe3e7843460f54eecb0f726"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad478cc51fbe3e7843460f54eecb0f726">grams</a> (const std::initializer_list&lt; Derived &gt; &amp;Vs)</td></tr>
<tr class="memdesc:ad478cc51fbe3e7843460f54eecb0f726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization (std::initializer_list overload)  <a href="#ad478cc51fbe3e7843460f54eecb0f726">More...</a><br /></td></tr>
<tr class="separator:ad478cc51fbe3e7843460f54eecb0f726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46120dde34a67d551a3e118f908fdcd1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a46120dde34a67d551a3e118f908fdcd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a46120dde34a67d551a3e118f908fdcd1">grams</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a46120dde34a67d551a3e118f908fdcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gram-Schmidt orthogonalization (Eigen expression (matrix) overload)  <a href="#a46120dde34a67d551a3e118f908fdcd1">More...</a><br /></td></tr>
<tr class="separator:a46120dde34a67d551a3e118f908fdcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe051c49a6c9c5a1cbb6401f95143a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afbe051c49a6c9c5a1cbb6401f95143a8">n2multiidx</a> (std::size_t n, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:afbe051c49a6c9c5a1cbb6401f95143a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-negative integer index to multi-index.  <a href="#afbe051c49a6c9c5a1cbb6401f95143a8">More...</a><br /></td></tr>
<tr class="separator:afbe051c49a6c9c5a1cbb6401f95143a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19badf6efe78383485b2ba28e4136bb7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a19badf6efe78383485b2ba28e4136bb7">multiidx2n</a> (const std::vector&lt; std::size_t &gt; &amp;midx, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a19badf6efe78383485b2ba28e4136bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-index to non-negative integer index.  <a href="#a19badf6efe78383485b2ba28e4136bb7">More...</a><br /></td></tr>
<tr class="separator:a19badf6efe78383485b2ba28e4136bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ade48c09bb33df893d7ff62a098374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a94ade48c09bb33df893d7ff62a098374">mket</a> (const std::vector&lt; std::size_t &gt; &amp;mask, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a94ade48c09bb33df893d7ff62a098374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-partite qudit ket (different dimensions overload)  <a href="#a94ade48c09bb33df893d7ff62a098374">More...</a><br /></td></tr>
<tr class="separator:a94ade48c09bb33df893d7ff62a098374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b2d9874a3688fbb56eaff32f9acc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab7b2d9874a3688fbb56eaff32f9acc7d">mket</a> (const std::vector&lt; std::size_t &gt; &amp;mask, std::size_t d=2)</td></tr>
<tr class="memdesc:ab7b2d9874a3688fbb56eaff32f9acc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-partite qudit ket (same dimensions overload)  <a href="#ab7b2d9874a3688fbb56eaff32f9acc7d">More...</a><br /></td></tr>
<tr class="separator:ab7b2d9874a3688fbb56eaff32f9acc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af881bc85f432ae9ee8a41a34b9ffae07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af881bc85f432ae9ee8a41a34b9ffae07">mprj</a> (const std::vector&lt; std::size_t &gt; &amp;mask, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:af881bc85f432ae9ee8a41a34b9ffae07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector onto multi-partite qudit ket (different dimensions overload)  <a href="#af881bc85f432ae9ee8a41a34b9ffae07">More...</a><br /></td></tr>
<tr class="separator:af881bc85f432ae9ee8a41a34b9ffae07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933550ccd7424593b89a7682469f3fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a933550ccd7424593b89a7682469f3fed">mprj</a> (const std::vector&lt; std::size_t &gt; &amp;mask, std::size_t d=2)</td></tr>
<tr class="memdesc:a933550ccd7424593b89a7682469f3fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projector onto multi-partite qudit ket (same dimensions overload)  <a href="#a933550ccd7424593b89a7682469f3fed">More...</a><br /></td></tr>
<tr class="separator:a933550ccd7424593b89a7682469f3fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9825a190c56286a68989b67620bbb9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a3e9825a190c56286a68989b67620bbb9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3e9825a190c56286a68989b67620bbb9">abssq</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a3e9825a190c56286a68989b67620bbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolut values squared of a range of complex numbers.  <a href="#a3e9825a190c56286a68989b67620bbb9">More...</a><br /></td></tr>
<tr class="separator:a3e9825a190c56286a68989b67620bbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7149763a7b4353138499b349d967303d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7149763a7b4353138499b349d967303d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a7149763a7b4353138499b349d967303d">abssq</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;V)</td></tr>
<tr class="memdesc:a7149763a7b4353138499b349d967303d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolut values squared of a column vector.  <a href="#a7149763a7b4353138499b349d967303d">More...</a><br /></td></tr>
<tr class="separator:a7149763a7b4353138499b349d967303d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beed28e8ce824a89484c6aeeb9ea24e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a9beed28e8ce824a89484c6aeeb9ea24e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9beed28e8ce824a89484c6aeeb9ea24e">sum</a> (InputIterator first, InputIterator last) -&gt; typename InputIterator::value_type</td></tr>
<tr class="memdesc:a9beed28e8ce824a89484c6aeeb9ea24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise sum of a range.  <a href="#a9beed28e8ce824a89484c6aeeb9ea24e">More...</a><br /></td></tr>
<tr class="separator:a9beed28e8ce824a89484c6aeeb9ea24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f10cf7a2845946fedfac88e6a9081f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ab7f10cf7a2845946fedfac88e6a9081f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab7f10cf7a2845946fedfac88e6a9081f">prod</a> (InputIterator first, InputIterator last) -&gt; typename InputIterator::value_type</td></tr>
<tr class="memdesc:ab7f10cf7a2845946fedfac88e6a9081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise product of a range.  <a href="#ab7f10cf7a2845946fedfac88e6a9081f">More...</a><br /></td></tr>
<tr class="separator:ab7f10cf7a2845946fedfac88e6a9081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1805e175751ef749374e3c8499f15d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4f1805e175751ef749374e3c8499f15d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d">disp</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, double <a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a>=<a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a>)</td></tr>
<tr class="memdesc:a4f1805e175751ef749374e3c8499f15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen expression ostream manipulator.  <a href="#a4f1805e175751ef749374e3c8499f15d">More...</a><br /></td></tr>
<tr class="separator:a4f1805e175751ef749374e3c8499f15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a815b8e5cf5cd3ab4c463bf53eb550dbf">disp</a> (<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a> z, double <a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a>=<a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a>)</td></tr>
<tr class="memdesc:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex number ostream manipulator.  <a href="#a815b8e5cf5cd3ab4c463bf53eb550dbf">More...</a><br /></td></tr>
<tr class="separator:a815b8e5cf5cd3ab4c463bf53eb550dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60298648d39542ac44effa9fe73d41c9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a60298648d39542ac44effa9fe73d41c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a><br class="typebreak" />
&lt; InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a60298648d39542ac44effa9fe73d41c9">disp</a> (const InputIterator &amp;first, const InputIterator &amp;last, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;)</td></tr>
<tr class="memdesc:a60298648d39542ac44effa9fe73d41c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range ostream manipulator.  <a href="#a60298648d39542ac44effa9fe73d41c9">More...</a><br /></td></tr>
<tr class="separator:a60298648d39542ac44effa9fe73d41c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ad6985e72b70282708a637cf42e7b"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:afc2ad6985e72b70282708a637cf42e7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
Container::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#afc2ad6985e72b70282708a637cf42e7b">disp</a> (const Container &amp;c, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;)</td></tr>
<tr class="memdesc:afc2ad6985e72b70282708a637cf42e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard container ostream manipulator. The container must support std::begin(), std::end() and forward iteration.  <a href="#afc2ad6985e72b70282708a637cf42e7b">More...</a><br /></td></tr>
<tr class="separator:afc2ad6985e72b70282708a637cf42e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e8f13a0bb318a28e1066a8fe5b3ce0"><td class="memTemplParams" colspan="2">template&lt;typename PointerType &gt; </td></tr>
<tr class="memitem:af6e8f13a0bb318a28e1066a8fe5b3ce0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_pointer.html">internal::IOManipPointer</a><br class="typebreak" />
&lt; PointerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af6e8f13a0bb318a28e1066a8fe5b3ce0">disp</a> (const PointerType *p, std::size_t n, const std::string &amp;separator, const std::string &amp;start=&quot;[&quot;, const std::string &amp;end=&quot;]&quot;)</td></tr>
<tr class="memdesc:af6e8f13a0bb318a28e1066a8fe5b3ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-style pointer ostream manipulator.  <a href="#af6e8f13a0bb318a28e1066a8fe5b3ce0">More...</a><br /></td></tr>
<tr class="separator:af6e8f13a0bb318a28e1066a8fe5b3ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238cf516513837235fbc7d7d283f7b78"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a238cf516513837235fbc7d7d283f7b78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a238cf516513837235fbc7d7d283f7b78">save</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::string &amp;fname)</td></tr>
<tr class="memdesc:a238cf516513837235fbc7d7d283f7b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves Eigen expression to a binary file (internal format) in double precision.  <a href="#a238cf516513837235fbc7d7d283f7b78">More...</a><br /></td></tr>
<tr class="separator:a238cf516513837235fbc7d7d283f7b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217e8ae6b09ac3cc89415d4b6204fda6"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a217e8ae6b09ac3cc89415d4b6204fda6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a217e8ae6b09ac3cc89415d4b6204fda6">load</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a217e8ae6b09ac3cc89415d4b6204fda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Eigen matrix from a binary file (internal format) in double precision.  <a href="#a217e8ae6b09ac3cc89415d4b6204fda6">More...</a><br /></td></tr>
<tr class="separator:a217e8ae6b09ac3cc89415d4b6204fda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5cf97f5ee0fbdeae163c0f77e28d6"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a27f5cf97f5ee0fbdeae163c0f77e28d6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a27f5cf97f5ee0fbdeae163c0f77e28d6">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a27f5cf97f5ee0fbdeae163c0f77e28d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>.  <a href="#a27f5cf97f5ee0fbdeae163c0f77e28d6">More...</a><br /></td></tr>
<tr class="separator:a27f5cf97f5ee0fbdeae163c0f77e28d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e3ae31fe7cd58136a4072dcfc389e9"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a06e3ae31fe7cd58136a4072dcfc389e9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a06e3ae31fe7cd58136a4072dcfc389e9">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::initializer_list&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a06e3ae31fe7cd58136a4072dcfc389e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em> (std::initializer_list overload)  <a href="#a06e3ae31fe7cd58136a4072dcfc389e9">More...</a><br /></td></tr>
<tr class="separator:a06e3ae31fe7cd58136a4072dcfc389e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb62ddad1b66794b3cfd74d80f8aaf9"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6bb62ddad1b66794b3cfd74d80f8aaf9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; double &gt;<br class="typebreak" />
, std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6bb62ddad1b66794b3cfd74d80f8aaf9">measure</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &amp;M)</td></tr>
<tr class="memdesc:a6bb62ddad1b66794b3cfd74d80f8aaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the state <em>A</em> in the orthonormal basis specified by the eigenvectors of <em>M</em>.  <a href="#a6bb62ddad1b66794b3cfd74d80f8aaf9">More...</a><br /></td></tr>
<tr class="separator:a6bb62ddad1b66794b3cfd74d80f8aaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a0f3023e1895d22de4e5f3e727e1dd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a84a0f3023e1895d22de4e5f3e727e1dd"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a84a0f3023e1895d22de4e5f3e727e1dd">loadMATLABmatrix</a> (const std::string &amp;mat_file, const std::string &amp;var_name)</td></tr>
<tr class="memdesc:a84a0f3023e1895d22de4e5f3e727e1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an Eigen dynamic matrix from a MATLAB .mat file, generic version.  <a href="#a84a0f3023e1895d22de4e5f3e727e1dd">More...</a><br /></td></tr>
<tr class="separator:a84a0f3023e1895d22de4e5f3e727e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2030161b0158746beaac80612a3464e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa2030161b0158746beaac80612a3464e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa2030161b0158746beaac80612a3464e">loadMATLABmatrix</a> (const std::string &amp;mat_file, const std::string &amp;var_name)</td></tr>
<tr class="memdesc:aa2030161b0158746beaac80612a3464e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an Eigen dynamic matrix from a MATLAB .mat file, specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>)  <a href="#aa2030161b0158746beaac80612a3464e">More...</a><br /></td></tr>
<tr class="separator:aa2030161b0158746beaac80612a3464e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26858bfbbec50369d19270c7bf329afa"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a26858bfbbec50369d19270c7bf329afa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a26858bfbbec50369d19270c7bf329afa">loadMATLABmatrix</a> (const std::string &amp;mat_file, const std::string &amp;var_name)</td></tr>
<tr class="memdesc:a26858bfbbec50369d19270c7bf329afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an Eigen dynamic matrix from a MATLAB .mat file, specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>)  <a href="#a26858bfbbec50369d19270c7bf329afa">More...</a><br /></td></tr>
<tr class="separator:a26858bfbbec50369d19270c7bf329afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d10a1f7c02f69d876a28133893d082"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a38d10a1f7c02f69d876a28133893d082"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a38d10a1f7c02f69d876a28133893d082">saveMATLABmatrix</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::string &amp;mat_file, const std::string &amp;var_name, const std::string &amp;mode)</td></tr>
<tr class="memdesc:a38d10a1f7c02f69d876a28133893d082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an Eigen dynamic matrix to a MATLAB .mat file, generic version.  <a href="#a38d10a1f7c02f69d876a28133893d082">More...</a><br /></td></tr>
<tr class="separator:a38d10a1f7c02f69d876a28133893d082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a40410f15a82495cabcd3641a788cd"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a37a40410f15a82495cabcd3641a788cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a37a40410f15a82495cabcd3641a788cd">saveMATLABmatrix</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> &gt; &amp;A, const std::string &amp;mat_file, const std::string &amp;var_name, const std::string &amp;mode)</td></tr>
<tr class="memdesc:a37a40410f15a82495cabcd3641a788cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an Eigen dynamic matrix to a MATLAB .mat file, specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>)  <a href="#a37a40410f15a82495cabcd3641a788cd">More...</a><br /></td></tr>
<tr class="separator:a37a40410f15a82495cabcd3641a788cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5cc697b513a7f0e5bdab3f357df173"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2f5cc697b513a7f0e5bdab3f357df173"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a2f5cc697b513a7f0e5bdab3f357df173">saveMATLABmatrix</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;A, const std::string &amp;mat_file, const std::string &amp;var_name, const std::string &amp;mode)</td></tr>
<tr class="memdesc:a2f5cc697b513a7f0e5bdab3f357df173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an Eigen dynamic matrix to a MATLAB .mat file, specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>)  <a href="#a2f5cc697b513a7f0e5bdab3f357df173">More...</a><br /></td></tr>
<tr class="separator:a2f5cc697b513a7f0e5bdab3f357df173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569c5700863d7054bea8e36f26d9930b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a569c5700863d7054bea8e36f26d9930b">x2contfrac</a> (double x, std::size_t n, std::size_t cut=1e5)</td></tr>
<tr class="memdesc:a569c5700863d7054bea8e36f26d9930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple continued fraction expansion.  <a href="#a569c5700863d7054bea8e36f26d9930b">More...</a><br /></td></tr>
<tr class="separator:a569c5700863d7054bea8e36f26d9930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1511e4d5c07691627c88e66070873b1b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1511e4d5c07691627c88e66070873b1b">contfrac2x</a> (const std::vector&lt; int &gt; &amp;cf, std::size_t n)</td></tr>
<tr class="memdesc:a1511e4d5c07691627c88e66070873b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real representation of a simple continued fraction.  <a href="#a1511e4d5c07691627c88e66070873b1b">More...</a><br /></td></tr>
<tr class="separator:a1511e4d5c07691627c88e66070873b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155296775ac0c0cd0cfe52c2ade8f14c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a155296775ac0c0cd0cfe52c2ade8f14c">contfrac2x</a> (const std::vector&lt; int &gt; &amp;cf)</td></tr>
<tr class="memdesc:a155296775ac0c0cd0cfe52c2ade8f14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real representation of a simple continued fraction.  <a href="#a155296775ac0c0cd0cfe52c2ade8f14c">More...</a><br /></td></tr>
<tr class="separator:a155296775ac0c0cd0cfe52c2ade8f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae245a12a1f7c9ab36da26498b2c4da96"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae245a12a1f7c9ab36da26498b2c4da96">gcd</a> (std::size_t m, std::size_t n)</td></tr>
<tr class="memdesc:ae245a12a1f7c9ab36da26498b2c4da96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest common divisor of two non-negative integers.  <a href="#ae245a12a1f7c9ab36da26498b2c4da96">More...</a><br /></td></tr>
<tr class="separator:ae245a12a1f7c9ab36da26498b2c4da96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b06a1ed3f09f5296470d4c180d9edc"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac6b06a1ed3f09f5296470d4c180d9edc">gcd</a> (const std::vector&lt; std::size_t &gt; &amp;ns)</td></tr>
<tr class="memdesc:ac6b06a1ed3f09f5296470d4c180d9edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greatest common divisor of a list of non-negative integers.  <a href="#ac6b06a1ed3f09f5296470d4c180d9edc">More...</a><br /></td></tr>
<tr class="separator:ac6b06a1ed3f09f5296470d4c180d9edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ded4330bac75ed34190b1c40d53381"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a37ded4330bac75ed34190b1c40d53381">lcm</a> (std::size_t m, std::size_t n)</td></tr>
<tr class="memdesc:a37ded4330bac75ed34190b1c40d53381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least common multiple of two positive integers.  <a href="#a37ded4330bac75ed34190b1c40d53381">More...</a><br /></td></tr>
<tr class="separator:a37ded4330bac75ed34190b1c40d53381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd094d5bde1344756f98167abb079f5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0cd094d5bde1344756f98167abb079f5">lcm</a> (const std::vector&lt; std::size_t &gt; &amp;ns)</td></tr>
<tr class="memdesc:a0cd094d5bde1344756f98167abb079f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Least common multiple of a list of positive integers.  <a href="#a0cd094d5bde1344756f98167abb079f5">More...</a><br /></td></tr>
<tr class="separator:a0cd094d5bde1344756f98167abb079f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2093db36b11503a66f77301fbbedb5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6a2093db36b11503a66f77301fbbedb5">invperm</a> (const std::vector&lt; std::size_t &gt; &amp;perm)</td></tr>
<tr class="memdesc:a6a2093db36b11503a66f77301fbbedb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse permutation.  <a href="#a6a2093db36b11503a66f77301fbbedb5">More...</a><br /></td></tr>
<tr class="separator:a6a2093db36b11503a66f77301fbbedb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ff84d3dba1a25530b8118e1feb39d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac0ff84d3dba1a25530b8118e1feb39d2">compperm</a> (const std::vector&lt; std::size_t &gt; &amp;perm, const std::vector&lt; std::size_t &gt; &amp;sigma)</td></tr>
<tr class="memdesc:ac0ff84d3dba1a25530b8118e1feb39d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose permutations.  <a href="#ac0ff84d3dba1a25530b8118e1feb39d2">More...</a><br /></td></tr>
<tr class="separator:ac0ff84d3dba1a25530b8118e1feb39d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d88751cff72495fccdcfa77b74d1729"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a1d88751cff72495fccdcfa77b74d1729"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1d88751cff72495fccdcfa77b74d1729">applyCTRL</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;ctrl, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a1d88751cff72495fccdcfa77b74d1729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of a multi-partite state vector or density matrix.  <a href="#a1d88751cff72495fccdcfa77b74d1729">More...</a><br /></td></tr>
<tr class="separator:a1d88751cff72495fccdcfa77b74d1729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcea8c285d9dd3fdedf166266a782ab"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a1dcea8c285d9dd3fdedf166266a782ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a1dcea8c285d9dd3fdedf166266a782ab">applyCTRL</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;ctrl, const std::vector&lt; std::size_t &gt; &amp;subsys, std::size_t d=2)</td></tr>
<tr class="memdesc:a1dcea8c285d9dd3fdedf166266a782ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of a multi-partite state vector or density matrix.  <a href="#a1dcea8c285d9dd3fdedf166266a782ab">More...</a><br /></td></tr>
<tr class="separator:a1dcea8c285d9dd3fdedf166266a782ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f5f4c236713542560dfeb8237c76f7"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a15f5f4c236713542560dfeb8237c76f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a15f5f4c236713542560dfeb8237c76f7">apply</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a15f5f4c236713542560dfeb8237c76f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the gate <em>A</em> to the part <em>subsys</em> of a multi-partite state vector or density matrix.  <a href="#a15f5f4c236713542560dfeb8237c76f7">More...</a><br /></td></tr>
<tr class="separator:a15f5f4c236713542560dfeb8237c76f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a237b102353f57c7243356a82cba36"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a02a237b102353f57c7243356a82cba36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a02a237b102353f57c7243356a82cba36">apply</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;state, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, std::size_t d=2)</td></tr>
<tr class="memdesc:a02a237b102353f57c7243356a82cba36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the gate <em>A</em> to the part <em>subsys</em> of a multi-partite state vector or density matrix.  <a href="#a02a237b102353f57c7243356a82cba36">More...</a><br /></td></tr>
<tr class="separator:a02a237b102353f57c7243356a82cba36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d3ed33a419331f7e9721b5fa602e2c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af6d3ed33a419331f7e9721b5fa602e2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af6d3ed33a419331f7e9721b5fa602e2c">channel</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;rho, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:af6d3ed33a419331f7e9721b5fa602e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the density matrix <em>rho</em>.  <a href="#af6d3ed33a419331f7e9721b5fa602e2c">More...</a><br /></td></tr>
<tr class="separator:af6d3ed33a419331f7e9721b5fa602e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8420993c681e0dc2e9ed41bddf109dcd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8420993c681e0dc2e9ed41bddf109dcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8420993c681e0dc2e9ed41bddf109dcd">channel</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;rho, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a8420993c681e0dc2e9ed41bddf109dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part of the density matrix <em>rho</em> specified by <em>subsys</em>.  <a href="#a8420993c681e0dc2e9ed41bddf109dcd">More...</a><br /></td></tr>
<tr class="separator:a8420993c681e0dc2e9ed41bddf109dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa64db27df5e0156a53227f0bd932df"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4aa64db27df5e0156a53227f0bd932df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a4aa64db27df5e0156a53227f0bd932df">channel</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;rho, const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks, const std::vector&lt; std::size_t &gt; &amp;subsys, std::size_t d=2)</td></tr>
<tr class="memdesc:a4aa64db27df5e0156a53227f0bd932df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part of the density matrix <em>rho</em> specified by <em>subsys</em>.  <a href="#a4aa64db27df5e0156a53227f0bd932df">More...</a><br /></td></tr>
<tr class="separator:a4aa64db27df5e0156a53227f0bd932df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d1de5e72943a61c35ab634690a841b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a54d1de5e72943a61c35ab634690a841b">super</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:a54d1de5e72943a61c35ab634690a841b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superoperator matrix representation.  <a href="#a54d1de5e72943a61c35ab634690a841b">More...</a><br /></td></tr>
<tr class="separator:a54d1de5e72943a61c35ab634690a841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f061a25c22b9d79d2536dc4ea738c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac8f061a25c22b9d79d2536dc4ea738c9">choi</a> (const std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt; &amp;Ks)</td></tr>
<tr class="memdesc:ac8f061a25c22b9d79d2536dc4ea738c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choi matrix representation.  <a href="#ac8f061a25c22b9d79d2536dc4ea738c9">More...</a><br /></td></tr>
<tr class="separator:ac8f061a25c22b9d79d2536dc4ea738c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08330f1578fa6b6e382a80132dffb46"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac08330f1578fa6b6e382a80132dffb46">choi2kraus</a> (const <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &amp;A)</td></tr>
<tr class="memdesc:ac08330f1578fa6b6e382a80132dffb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts orthogonal Kraus operators from Choi matrix.  <a href="#ac08330f1578fa6b6e382a80132dffb46">More...</a><br /></td></tr>
<tr class="separator:ac08330f1578fa6b6e382a80132dffb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89291882069b2a76650a082029dc4e94"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a89291882069b2a76650a082029dc4e94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a89291882069b2a76650a082029dc4e94">ptrace1</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a89291882069b2a76650a082029dc4e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a89291882069b2a76650a082029dc4e94">More...</a><br /></td></tr>
<tr class="separator:a89291882069b2a76650a082029dc4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae846df6b2525ef728947e00c2074e8b6"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae846df6b2525ef728947e00c2074e8b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae846df6b2525ef728947e00c2074e8b6">ptrace2</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:ae846df6b2525ef728947e00c2074e8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#ae846df6b2525ef728947e00c2074e8b6">More...</a><br /></td></tr>
<tr class="separator:ae846df6b2525ef728947e00c2074e8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fef47d40c93533b586f9b90a97c3621"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5fef47d40c93533b586f9b90a97c3621"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5fef47d40c93533b586f9b90a97c3621">ptrace</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a5fef47d40c93533b586f9b90a97c3621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial trace.  <a href="#a5fef47d40c93533b586f9b90a97c3621">More...</a><br /></td></tr>
<tr class="separator:a5fef47d40c93533b586f9b90a97c3621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0893a2a4dcfd11696a0e675da03f8f61"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0893a2a4dcfd11696a0e675da03f8f61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a0893a2a4dcfd11696a0e675da03f8f61">ptranspose</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;subsys, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:a0893a2a4dcfd11696a0e675da03f8f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial transpose.  <a href="#a0893a2a4dcfd11696a0e675da03f8f61">More...</a><br /></td></tr>
<tr class="separator:a0893a2a4dcfd11696a0e675da03f8f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97cab67fadb870ad19be297b4422ca1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af97cab67fadb870ad19be297b4422ca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af97cab67fadb870ad19be297b4422ca1">syspermute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const std::vector&lt; std::size_t &gt; &amp;perm, const std::vector&lt; std::size_t &gt; &amp;dims)</td></tr>
<tr class="memdesc:af97cab67fadb870ad19be297b4422ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">System permutation.  <a href="#af97cab67fadb870ad19be297b4422ca1">More...</a><br /></td></tr>
<tr class="separator:af97cab67fadb870ad19be297b4422ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62c1a613ce4252c37eb12fb5b8f009f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af62c1a613ce4252c37eb12fb5b8f009f"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#af62c1a613ce4252c37eb12fb5b8f009f">rand</a> (std::size_t rows, std::size_t cols, double a=0, double b=1)</td></tr>
<tr class="memdesc:af62c1a613ce4252c37eb12fb5b8f009f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random matrix with entries uniformly distributed in the interval [a, b)  <a href="#af62c1a613ce4252c37eb12fb5b8f009f">More...</a><br /></td></tr>
<tr class="separator:af62c1a613ce4252c37eb12fb5b8f009f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef453d90b3165bc013e62bf952e5f84"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6ef453d90b3165bc013e62bf952e5f84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6ef453d90b3165bc013e62bf952e5f84">rand</a> (std::size_t rows, std::size_t cols, double a, double b)</td></tr>
<tr class="memdesc:a6ef453d90b3165bc013e62bf952e5f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real matrix with entries uniformly distributed in the interval [a, b), specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>)  <a href="#a6ef453d90b3165bc013e62bf952e5f84">More...</a><br /></td></tr>
<tr class="separator:a6ef453d90b3165bc013e62bf952e5f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768c04399d0c1cf14fc509bf86a1030e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a768c04399d0c1cf14fc509bf86a1030e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a768c04399d0c1cf14fc509bf86a1030e">rand</a> (std::size_t rows, std::size_t cols, double a, double b)</td></tr>
<tr class="memdesc:a768c04399d0c1cf14fc509bf86a1030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random complex matrix with entries (both real and imaginary) uniformly distributed in the interval [a, b), specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>)  <a href="#a768c04399d0c1cf14fc509bf86a1030e">More...</a><br /></td></tr>
<tr class="separator:a768c04399d0c1cf14fc509bf86a1030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a75700e99974758b39948e65536407"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a98a75700e99974758b39948e65536407">rand</a> (double a=0, double b=1)</td></tr>
<tr class="memdesc:a98a75700e99974758b39948e65536407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real number uniformly distributed in the interval [a, b)  <a href="#a98a75700e99974758b39948e65536407">More...</a><br /></td></tr>
<tr class="separator:a98a75700e99974758b39948e65536407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8b50941df1b415f0b62a2825211f73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aaa8b50941df1b415f0b62a2825211f73">randint</a> (int a=std::numeric_limits&lt; int &gt;::min(), int b=std::numeric_limits&lt; int &gt;::max())</td></tr>
<tr class="memdesc:aaa8b50941df1b415f0b62a2825211f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random integer (int) uniformly distributed in the interval [a, b].  <a href="#aaa8b50941df1b415f0b62a2825211f73">More...</a><br /></td></tr>
<tr class="separator:aaa8b50941df1b415f0b62a2825211f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5c9d92baf1749ca84aa099e7991bd5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:adb5c9d92baf1749ca84aa099e7991bd5"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#adb5c9d92baf1749ca84aa099e7991bd5">randn</a> (std::size_t rows, std::size_t cols, double mean=0, double sigma=1)</td></tr>
<tr class="memdesc:adb5c9d92baf1749ca84aa099e7991bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random matrix with entries normally distributed in N(mean, sigma)  <a href="#adb5c9d92baf1749ca84aa099e7991bd5">More...</a><br /></td></tr>
<tr class="separator:adb5c9d92baf1749ca84aa099e7991bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351821ffae682d9365179225a46de1ea"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a351821ffae682d9365179225a46de1ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a351821ffae682d9365179225a46de1ea">randn</a> (std::size_t rows, std::size_t cols, double mean, double sigma)</td></tr>
<tr class="memdesc:a351821ffae682d9365179225a46de1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real matrix with entries normally distributed in N(mean, sigma), specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>)  <a href="#a351821ffae682d9365179225a46de1ea">More...</a><br /></td></tr>
<tr class="separator:a351821ffae682d9365179225a46de1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b46bbd2051993d38e7557da12cb47"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a219b46bbd2051993d38e7557da12cb47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a219b46bbd2051993d38e7557da12cb47">randn</a> (std::size_t rows, std::size_t cols, double mean, double sigma)</td></tr>
<tr class="memdesc:a219b46bbd2051993d38e7557da12cb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random complex matrix with entries (both real and imaginary) normally distributed in N(mean, sigma), specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>)  <a href="#a219b46bbd2051993d38e7557da12cb47">More...</a><br /></td></tr>
<tr class="separator:a219b46bbd2051993d38e7557da12cb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab967280114b9e2003bd559c840a5f0e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ab967280114b9e2003bd559c840a5f0e6">randn</a> (double mean=0, double sigma=1)</td></tr>
<tr class="memdesc:ab967280114b9e2003bd559c840a5f0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random real number (double) normally distributed in N(mean, sigma)  <a href="#ab967280114b9e2003bd559c840a5f0e6">More...</a><br /></td></tr>
<tr class="separator:ab967280114b9e2003bd559c840a5f0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c63023791941918aad0894de4ba1eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5c63023791941918aad0894de4ba1eb7">randU</a> (std::size_t D)</td></tr>
<tr class="memdesc:a5c63023791941918aad0894de4ba1eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random unitary matrix.  <a href="#a5c63023791941918aad0894de4ba1eb7">More...</a><br /></td></tr>
<tr class="separator:a5c63023791941918aad0894de4ba1eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f080960f87046e3b886dcd83f292bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ac2f080960f87046e3b886dcd83f292bd">randV</a> (std::size_t Din, std::size_t Dout)</td></tr>
<tr class="memdesc:ac2f080960f87046e3b886dcd83f292bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random isometry matrix.  <a href="#ac2f080960f87046e3b886dcd83f292bd">More...</a><br /></td></tr>
<tr class="separator:ac2f080960f87046e3b886dcd83f292bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a6e123647482a1673a51aa74aa6ca2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ad7a6e123647482a1673a51aa74aa6ca2">randkraus</a> (std::size_t N, std::size_t D)</td></tr>
<tr class="memdesc:ad7a6e123647482a1673a51aa74aa6ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a set of random Kraus operators.  <a href="#ad7a6e123647482a1673a51aa74aa6ca2">More...</a><br /></td></tr>
<tr class="separator:ad7a6e123647482a1673a51aa74aa6ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2a1d87be74a4d0d3cbbca6245417b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5a2a1d87be74a4d0d3cbbca6245417b5">randH</a> (std::size_t D)</td></tr>
<tr class="memdesc:a5a2a1d87be74a4d0d3cbbca6245417b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random Hermitian matrix.  <a href="#a5a2a1d87be74a4d0d3cbbca6245417b5">More...</a><br /></td></tr>
<tr class="separator:a5a2a1d87be74a4d0d3cbbca6245417b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8860e7f282dfd5a75b1292303bd703d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aa8860e7f282dfd5a75b1292303bd703d">randket</a> (std::size_t D)</td></tr>
<tr class="memdesc:aa8860e7f282dfd5a75b1292303bd703d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random normalized ket (pure state vector)  <a href="#aa8860e7f282dfd5a75b1292303bd703d">More...</a><br /></td></tr>
<tr class="separator:aa8860e7f282dfd5a75b1292303bd703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5751166c3171415976bd5aab3e5b70f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a5751166c3171415976bd5aab3e5b70f5">randrho</a> (std::size_t D)</td></tr>
<tr class="memdesc:a5751166c3171415976bd5aab3e5b70f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random density matrix.  <a href="#a5751166c3171415976bd5aab3e5b70f5">More...</a><br /></td></tr>
<tr class="separator:a5751166c3171415976bd5aab3e5b70f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6375dff8dd558f524bc0e7d3e261100f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a6375dff8dd558f524bc0e7d3e261100f">randperm</a> (std::size_t n)</td></tr>
<tr class="memdesc:a6375dff8dd558f524bc0e7d3e261100f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random uniformly distributed permutation.  <a href="#a6375dff8dd558f524bc0e7d3e261100f">More...</a><br /></td></tr>
<tr class="separator:a6375dff8dd558f524bc0e7d3e261100f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">chop</a> = 1e-10</td></tr>
<tr class="memdesc:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in <a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d" title="Eigen expression ostream manipulator. ">qpp::disp()</a> and <a class="el" href="namespaceqpp_1_1experimental.html#af4fec399593b70b3d54f213500807569" title="Displays a range. Adds a newline. ">qpp::displn()</a> for setting to zero numbers that have their absolute value smaller than qpp::ct::chop.  <a href="#a3a6d2c509bdcf240869e1bebb3be4e94">More...</a><br /></td></tr>
<tr class="separator:a3a6d2c509bdcf240869e1bebb3be4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6">eps</a> = 1e-12</td></tr>
<tr class="memdesc:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to decide whether a number or expression in double precision is zero or not.  <a href="#a9a99ccccd473a9006dfaadb5761ac4f6">More...</a><br /></td></tr>
<tr class="separator:a9a99ccccd473a9006dfaadb5761ac4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb5b9cd86de8efebf531f22f673489a"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a9cb5b9cd86de8efebf531f22f673489a">maxn</a> = 64</td></tr>
<tr class="memdesc:a9cb5b9cd86de8efebf531f22f673489a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of qubits.  <a href="#a9cb5b9cd86de8efebf531f22f673489a">More...</a><br /></td></tr>
<tr class="separator:a9cb5b9cd86de8efebf531f22f673489a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c04db6f636b236d64fddb069bef492"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a73c04db6f636b236d64fddb069bef492">pi</a> = 3.141592653589793238462643383279502884</td></tr>
<tr class="memdesc:a73c04db6f636b236d64fddb069bef492"><td class="mdescLeft">&#160;</td><td class="mdescRight"><img class="formulaInl" alt="$ \pi $" src="form_5.png"/>  <a href="#a73c04db6f636b236d64fddb069bef492">More...</a><br /></td></tr>
<tr class="separator:a73c04db6f636b236d64fddb069bef492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5c7e10fa94db0755cb937250144630"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aca5c7e10fa94db0755cb937250144630">ee</a> = 2.718281828459045235360287471352662497</td></tr>
<tr class="memdesc:aca5c7e10fa94db0755cb937250144630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base of natural logarithm, <img class="formulaInl" alt="$e$" src="form_6.png"/>.  <a href="#aca5c7e10fa94db0755cb937250144630">More...</a><br /></td></tr>
<tr class="separator:aca5c7e10fa94db0755cb937250144630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b4878f2b40f0dafeb5a437bfd88351"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a33b4878f2b40f0dafeb5a437bfd88351">infty</a> = -1</td></tr>
<tr class="memdesc:a33b4878f2b40f0dafeb5a437bfd88351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to denote infinity.  <a href="#a33b4878f2b40f0dafeb5a437bfd88351">More...</a><br /></td></tr>
<tr class="separator:a33b4878f2b40f0dafeb5a437bfd88351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4969dadb784a76f5182b791fb54198"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classqpp_1_1_init.html">Init</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#aca4969dadb784a76f5182b791fb54198">init</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Init::get_instance</a>()</td></tr>
<tr class="memdesc:aca4969dadb784a76f5182b791fb54198"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_init.html" title="const Singleton class that performs additional initializations/cleanups ">qpp::Init</a> const Singleton  <a href="#aca4969dadb784a76f5182b791fb54198">More...</a><br /></td></tr>
<tr class="separator:aca4969dadb784a76f5182b791fb54198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af5132edaed29c8d8233d1bb6ffa47a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classqpp_1_1_codes.html">Codes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a3af5132edaed29c8d8233d1bb6ffa47a">codes</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Codes::get_instance</a>()</td></tr>
<tr class="memdesc:a3af5132edaed29c8d8233d1bb6ffa47a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_codes.html" title="const Singleton class that defines quantum error correcting codes ">qpp::Codes</a> const Singleton  <a href="#a3af5132edaed29c8d8233d1bb6ffa47a">More...</a><br /></td></tr>
<tr class="separator:a3af5132edaed29c8d8233d1bb6ffa47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde5be3693c953f79e9c8e262447c8d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classqpp_1_1_gates.html">Gates</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#abde5be3693c953f79e9c8e262447c8d4">gt</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Gates::get_instance</a>()</td></tr>
<tr class="memdesc:abde5be3693c953f79e9c8e262447c8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_gates.html" title="const Singleton class that implements most commonly used gates ">qpp::Gates</a> const Singleton  <a href="#abde5be3693c953f79e9c8e262447c8d4">More...</a><br /></td></tr>
<tr class="separator:abde5be3693c953f79e9c8e262447c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf42bdf7cdbcc98543c7bf6ef36671d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classqpp_1_1_states.html">States</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#a8cf42bdf7cdbcc98543c7bf6ef36671d">st</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">States::get_instance</a>()</td></tr>
<tr class="memdesc:a8cf42bdf7cdbcc98543c7bf6ef36671d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_states.html" title="const Singleton class that implements most commonly used states ">qpp::States</a> const Singleton  <a href="#a8cf42bdf7cdbcc98543c7bf6ef36671d">More...</a><br /></td></tr>
<tr class="separator:a8cf42bdf7cdbcc98543c7bf6ef36671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae470c1750d1cc895763d1902f3a6882d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqpp_1_1_random_devices.html">RandomDevices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceqpp.html#ae470c1750d1cc895763d1902f3a6882d">rdevs</a> = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">RandomDevices::get_instance</a>()</td></tr>
<tr class="memdesc:ae470c1750d1cc895763d1902f3a6882d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqpp_1_1_random_devices.html" title="Singeleton class that manages the source of randomness in the library. ">qpp::RandomDevices</a> Singleton  <a href="#ae470c1750d1cc895763d1902f3a6882d">More...</a><br /></td></tr>
<tr class="separator:ae470c1750d1cc895763d1902f3a6882d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ad31e93771501f862f00d548105e153b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#ad31e93771501f862f00d548105e153b2">qpp::bra</a> = typedef <a class="el" href="namespaceqpp.html#a7fc6fdb793d3e2fcc393ac909ecb421d">DynRowVect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen row vector. </p>

</div>
</div>
<a class="anchor" id="a8b7b2a88cebcdddfde04c087eecf1328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">qpp::cmat</a> = typedef <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen matrix. </p>

</div>
</div>
<a class="anchor" id="aad7ccc50a6b139279d7b56d07112b183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">qpp::cplx</a> = typedef std::complex&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex number in double precision. </p>

</div>
</div>
<a class="anchor" id="a31d63fc80c90b84ab9ab7062f2d82d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">qpp::dmat</a> = typedef <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real (double precision) dynamic Eigen matrix. </p>

</div>
</div>
<a class="anchor" id="a23060a9e83c7da740a4459153dbd2c41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">qpp::DynColVect</a> = typedef Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen column vector over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> colvect = DynColVect&lt;float&gt;(2); <span class="comment">// type of colvect is Eigen::Matrix&lt;float, Eigen::Dynamic, 1&gt; </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a39fdcbcd3a12dd426ceab6d4aec4a281"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">qpp::DynMat</a> = typedef Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen matrix over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> mat = DynMat&lt;float&gt;(2,3); <span class="comment">// type of mat is Eigen::Matrix&lt;float, Eigen::Dynamic, Eigen::Dynamic&gt; </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7fc6fdb793d3e2fcc393ac909ecb421d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#a7fc6fdb793d3e2fcc393ac909ecb421d">qpp::DynRowVect</a> = typedef Eigen::Matrix&lt;Scalar, 1, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamic Eigen row vector over the field specified by <em>Scalar</em>. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> rowvect = DynRowVect&lt;float&gt;(3); <span class="comment">// type of rowvect is Eigen::Matrix&lt;float, 1, Eigen::Dynamic&gt; </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="add021f91288df8af3125cf4b2c8806e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">qpp::ket</a> = typedef <a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex (double precision) dynamic Eigen column vector. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3a4cb16d97f9cc763bd133b64f2b6f6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::absm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix absolut value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix absolut value of <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a3a4cb16d97f9cc763bd133b64f2b6f6d_cgraph.png" border="0" usemap="#namespaceqpp_a3a4cb16d97f9cc763bd133b64f2b6f6d_cgraph" alt=""/></div>
<map name="namespaceqpp_a3a4cb16d97f9cc763bd133b64f2b6f6d_cgraph" id="namespaceqpp_a3a4cb16d97f9cc763bd133b64f2b6f6d_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="539,125,673,166"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="539,302,673,343"/><area shape="rect" id="node4" href="namespaceqpp.html#a83e2b23bc11e3cb8dd6909969af7377c" title="Matrix square root. " alt="" coords="137,171,219,197"/><area shape="rect" id="node8" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="267,5,355,32"/><area shape="rect" id="node5" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="271,208,350,235"/><area shape="rect" id="node6" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="403,208,491,235"/><area shape="rect" id="node7" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="405,259,488,285"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3e9825a190c56286a68989b67620bbb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::abssq </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolut values squared of a range of complex numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the range's absolut values squared </dd></dl>

</div>
</div>
<a class="anchor" id="a7149763a7b4353138499b349d967303d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; qpp::abssq </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolut values squared of a column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real vector consisting of the absolut values squared </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a7149763a7b4353138499b349d967303d_cgraph.png" border="0" usemap="#namespaceqpp_a7149763a7b4353138499b349d967303d_cgraph" alt=""/></div>
<map name="namespaceqpp_a7149763a7b4353138499b349d967303d_cgraph" id="namespaceqpp_a7149763a7b4353138499b349d967303d_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="141,5,276,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="141,71,276,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac541afad6657467d9bd83c69345880a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::adjoint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Adjoint (Hermitian conjugate) of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ac541afad6657467d9bd83c69345880a2_cgraph.png" border="0" usemap="#namespaceqpp_ac541afad6657467d9bd83c69345880a2_cgraph" alt=""/></div>
<map name="namespaceqpp_ac541afad6657467d9bd83c69345880a2_cgraph" id="namespaceqpp_ac541afad6657467d9bd83c69345880a2_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="141,5,276,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0ca142339e1a19e0f08488dbc3cf3e71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::anticomm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Anti-commutator. </p>
<p>Anti-commutator <img class="formulaInl" alt="$ \{A,B\} = AB + BA $" src="form_31.png"/><br />
 Both <em>A</em> and <em>B</em> must be Eigen expressions over the same scalar field</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">B</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Anti-commutator <img class="formulaInl" alt="$AB +BA$" src="form_32.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a0ca142339e1a19e0f08488dbc3cf3e71_cgraph.png" border="0" usemap="#namespaceqpp_a0ca142339e1a19e0f08488dbc3cf3e71_cgraph" alt=""/></div>
<map name="namespaceqpp_a0ca142339e1a19e0f08488dbc3cf3e71_cgraph" id="namespaceqpp_a0ca142339e1a19e0f08488dbc3cf3e71_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="157,5,292,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="157,71,292,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a15f5f4c236713542560dfeb8237c76f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the gate <em>A</em> to the part <em>subsys</em> of a multi-partite state vector or density matrix. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gate <em>A</em> applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a15f5f4c236713542560dfeb8237c76f7_cgraph.png" border="0" usemap="#namespaceqpp_a15f5f4c236713542560dfeb8237c76f7_cgraph" alt=""/></div>
<map name="namespaceqpp_a15f5f4c236713542560dfeb8237c76f7_cgraph" id="namespaceqpp_a15f5f4c236713542560dfeb8237c76f7_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="520,443,655,484"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="520,620,655,661"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="304,61,472,87"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="315,112,461,153"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="321,177,455,219"/><area shape="rect" id="node7" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="321,243,455,284"/><area shape="rect" id="node8" href="namespaceqpp_1_1internal.html#a49b8ec606333c1cf8da35aa42e94c528" title="qpp::internal::_check\l_dims_match_cvect" alt="" coords="321,308,455,349"/><area shape="rect" id="node9" href="namespaceqpp.html#a1d88751cff72495fccdcfa77b74d1729" title="Applies the controlled&#45;gate A to the part subsys of a multi&#45;partite state vector or density matrix..." alt="" coords="137,365,256,391"/><area shape="rect" id="node10" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="345,577,431,603"/><area shape="rect" id="node11" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="344,526,432,553"/><area shape="rect" id="node12" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="309,425,467,451"/><area shape="rect" id="node13" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="309,475,467,502"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a02a237b102353f57c7243356a82cba36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::apply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the gate <em>A</em> to the part <em>subsys</em> of a multi-partite state vector or density matrix. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">d</td><td>Local dimensions of all local Hilbert spaces (must all be equal) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gate <em>A</em> applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a02a237b102353f57c7243356a82cba36_cgraph.png" border="0" usemap="#namespaceqpp_a02a237b102353f57c7243356a82cba36_cgraph" alt=""/></div>
<map name="namespaceqpp_a02a237b102353f57c7243356a82cba36_cgraph" id="namespaceqpp_a02a237b102353f57c7243356a82cba36_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="652,204,787,246"/><area shape="rect" id="node3" href="namespaceqpp.html#a15f5f4c236713542560dfeb8237c76f7" title="Applies the gate A to the part subsys of a multi&#45;partite state vector or density matrix. " alt="" coords="137,364,221,390"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="652,407,787,448"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="436,516,604,542"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="447,567,593,608"/><area shape="rect" id="node7" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="453,632,587,674"/><area shape="rect" id="node8" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="453,80,587,122"/><area shape="rect" id="node9" href="namespaceqpp_1_1internal.html#a49b8ec606333c1cf8da35aa42e94c528" title="qpp::internal::_check\l_dims_match_cvect" alt="" coords="453,146,587,187"/><area shape="rect" id="node10" href="namespaceqpp.html#a1d88751cff72495fccdcfa77b74d1729" title="Applies the controlled&#45;gate A to the part subsys of a multi&#45;partite state vector or density matrix..." alt="" coords="269,364,388,390"/><area shape="rect" id="node11" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="477,364,563,390"/><area shape="rect" id="node12" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="476,262,564,289"/><area shape="rect" id="node13" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="441,313,599,340"/><area shape="rect" id="node14" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="441,465,599,492"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1d88751cff72495fccdcfa77b74d1729"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::applyCTRL </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of a multi-partite state vector or density matrix. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em>. Also, all control subsystems in <em>ctrl</em> must have the same dimension.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">ctrl</td><td>Control subsystem indexes </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CTRL-A gate applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a1d88751cff72495fccdcfa77b74d1729_cgraph.png" border="0" usemap="#namespaceqpp_a1d88751cff72495fccdcfa77b74d1729_cgraph" alt=""/></div>
<map name="namespaceqpp_a1d88751cff72495fccdcfa77b74d1729_cgraph" id="namespaceqpp_a1d88751cff72495fccdcfa77b74d1729_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="388,275,523,316"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="388,16,523,58"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="172,100,340,126"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="183,151,329,192"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="189,216,323,258"/><area shape="rect" id="node7" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="213,49,299,76"/><area shape="rect" id="node8" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="212,333,300,360"/><area shape="rect" id="node9" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="177,384,335,410"/><area shape="rect" id="node10" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="177,434,335,461"/><area shape="rect" id="node11" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="189,486,323,527"/><area shape="rect" id="node12" href="namespaceqpp_1_1internal.html#a49b8ec606333c1cf8da35aa42e94c528" title="qpp::internal::_check\l_dims_match_cvect" alt="" coords="189,551,323,592"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1dcea8c285d9dd3fdedf166266a782ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::applyCTRL </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the controlled-gate <em>A</em> to the part <em>subsys</em> of a multi-partite state vector or density matrix. </p>
<dl class="section note"><dt>Note</dt><dd>The dimension of the gate <em>A</em> must match the dimension of <em>subsys</em> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">ctrl</td><td>Control subsystem indexes </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes where the gate <em>A</em> is applied </td></tr>
    <tr><td class="paramname">d</td><td>Local dimensions of all local Hilbert spaces (must all be equal) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CTRL-A gate applied to the part <em>subsys</em> of <em>state</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a1dcea8c285d9dd3fdedf166266a782ab_cgraph.png" border="0" usemap="#namespaceqpp_a1dcea8c285d9dd3fdedf166266a782ab_cgraph" alt=""/></div>
<map name="namespaceqpp_a1dcea8c285d9dd3fdedf166266a782ab_cgraph" id="namespaceqpp_a1dcea8c285d9dd3fdedf166266a782ab_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="555,122,689,163"/><area shape="rect" id="node3" href="namespaceqpp.html#a1d88751cff72495fccdcfa77b74d1729" title="Applies the controlled&#45;gate A to the part subsys of a multi&#45;partite state vector or density matrix..." alt="" coords="172,297,291,324"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="555,406,689,447"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="339,205,507,232"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="349,256,496,298"/><area shape="rect" id="node7" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="355,322,490,363"/><area shape="rect" id="node8" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="379,388,466,414"/><area shape="rect" id="node9" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="379,154,467,181"/><area shape="rect" id="node10" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="344,489,501,516"/><area shape="rect" id="node11" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="344,540,501,566"/><area shape="rect" id="node12" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="355,591,490,632"/><area shape="rect" id="node13" href="namespaceqpp_1_1internal.html#a49b8ec606333c1cf8da35aa42e94c528" title="qpp::internal::_check\l_dims_match_cvect" alt="" coords="355,38,490,79"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af6d3ed33a419331f7e9721b5fa602e2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::channel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the density matrix <em>rho</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_af6d3ed33a419331f7e9721b5fa602e2c_cgraph.png" border="0" usemap="#namespaceqpp_af6d3ed33a419331f7e9721b5fa602e2c_cgraph" alt=""/></div>
<map name="namespaceqpp_af6d3ed33a419331f7e9721b5fa602e2c_cgraph" id="namespaceqpp_af6d3ed33a419331f7e9721b5fa602e2c_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="331,25,465,67"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="148,25,283,67"/><area shape="rect" id="node4" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="171,91,259,118"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8420993c681e0dc2e9ed41bddf109dcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::channel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part of the density matrix <em>rho</em> specified by <em>subsys</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystems' indexes where the Kraus operators <em>Ks</em> are applied </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a8420993c681e0dc2e9ed41bddf109dcd_cgraph.png" border="0" usemap="#namespaceqpp_a8420993c681e0dc2e9ed41bddf109dcd_cgraph" alt=""/></div>
<map name="namespaceqpp_a8420993c681e0dc2e9ed41bddf109dcd_cgraph" id="namespaceqpp_a8420993c681e0dc2e9ed41bddf109dcd_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="663,246,797,288"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="663,500,797,541"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="447,71,615,98"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="463,609,598,650"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="457,674,604,716"/><area shape="rect" id="node7" href="namespaceqpp.html#a15f5f4c236713542560dfeb8237c76f7" title="Applies the gate A to the part subsys of a multi&#45;partite state vector or density matrix. " alt="" coords="148,355,232,382"/><area shape="rect" id="node8" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="463,122,598,164"/><area shape="rect" id="node9" href="namespaceqpp_1_1internal.html#a49b8ec606333c1cf8da35aa42e94c528" title="qpp::internal::_check\l_dims_match_cvect" alt="" coords="463,188,598,229"/><area shape="rect" id="node10" href="namespaceqpp.html#a1d88751cff72495fccdcfa77b74d1729" title="Applies the controlled&#45;gate A to the part subsys of a multi&#45;partite state vector or density matrix..." alt="" coords="280,355,399,382"/><area shape="rect" id="node11" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="487,406,574,432"/><area shape="rect" id="node12" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="487,304,575,331"/><area shape="rect" id="node13" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="452,507,609,534"/><area shape="rect" id="node14" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="452,355,609,382"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4aa64db27df5e0156a53227f0bd932df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::channel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the channel specified by the set of Kraus operators <em>Ks</em> to the part of the density matrix <em>rho</em> specified by <em>subsys</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystems' indexes where the Kraus operators <em>Ks</em> are applied </td></tr>
    <tr><td class="paramname">d</td><td>Local dimensions of all local Hilbert spaces (must all be equal) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output density matrix after the action of the channel </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a4aa64db27df5e0156a53227f0bd932df_cgraph.png" border="0" usemap="#namespaceqpp_a4aa64db27df5e0156a53227f0bd932df_cgraph" alt=""/></div>
<map name="namespaceqpp_a4aa64db27df5e0156a53227f0bd932df_cgraph" id="namespaceqpp_a4aa64db27df5e0156a53227f0bd932df_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="473,21,608,62"/><area shape="rect" id="node3" href="namespaceqpp.html#af6d3ed33a419331f7e9721b5fa602e2c" title="Applies the channel specified by the set of Kraus operators Ks to the density matrix rho..." alt="" coords="148,60,243,87"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="291,79,425,121"/><area shape="rect" id="node5" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="314,145,402,172"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac8f061a25c22b9d79d2536dc4ea738c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::choi </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choi matrix representation. </p>
<p>Constructs the Choi matrix of the channel specified by the set of Kraus operators <em>Ks</em> in the standard operator basis <img class="formulaInl" alt="$\{|i\rangle\langle j|\}$" src="form_15.png"/> ordered in lexicographical order, i.e. <img class="formulaInl" alt="$|0\rangle\langle 0|$" src="form_16.png"/>, <img class="formulaInl" alt="$|0\rangle\langle 1|$" src="form_17.png"/> etc.</p>
<dl class="section note"><dt>Note</dt><dd>The superoperator matrix <img class="formulaInl" alt="$S$" src="form_18.png"/> and the Choi matrix <img class="formulaInl" alt="$ C$" src="form_19.png"/> are related by <img class="formulaInl" alt="$ S_{ab,mn} = C_{ma,nb}$" src="form_20.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Choi matrix representation </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ac8f061a25c22b9d79d2536dc4ea738c9_cgraph.png" border="0" usemap="#namespaceqpp_ac8f061a25c22b9d79d2536dc4ea738c9_cgraph" alt=""/></div>
<map name="namespaceqpp_ac8f061a25c22b9d79d2536dc4ea738c9_cgraph" id="namespaceqpp_ac8f061a25c22b9d79d2536dc4ea738c9_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="309,29,444,70"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="127,29,261,70"/><area shape="rect" id="node4" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="150,95,238,121"/><area shape="rect" id="node5" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7" title="Kronecker product (variadic overload) " alt="" coords="157,145,231,172"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac08330f1578fa6b6e382a80132dffb46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; qpp::choi2kraus </td>
          <td>(</td>
          <td class="paramtype">const cmat &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts orthogonal Kraus operators from Choi matrix. </p>
<p>Extracts a set of orthogonal (under Hilbert-Schmidt operator norm) Kraus operators from the Choi representation <em>A</em> of the channel</p>
<dl class="section note"><dt>Note</dt><dd>The Kraus operators satisfy <img class="formulaInl" alt="$Tr(K_i^\dagger K_j)=\delta_{ij}$" src="form_35.png"/> for all <img class="formulaInl" alt="$i\neq j$" src="form_36.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Choi matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of Kraus operators </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ac08330f1578fa6b6e382a80132dffb46_cgraph.png" border="0" usemap="#namespaceqpp_ac08330f1578fa6b6e382a80132dffb46_cgraph" alt=""/></div>
<map name="namespaceqpp_ac08330f1578fa6b6e382a80132dffb46_cgraph" id="namespaceqpp_ac08330f1578fa6b6e382a80132dffb46_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="311,67,445,109"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="311,150,445,191"/><area shape="rect" id="node4" href="namespaceqpp.html#a96eb6e12c5bc0c544663f6705bc1c950" title="Hermitian eigenvalues. " alt="" coords="169,157,258,184"/><area shape="rect" id="node5" href="namespaceqpp.html#abeadaf6395c78a52339bec119c4a331b" title="Hermitian eigenvectors. " alt="" coords="166,107,261,133"/><area shape="rect" id="node6" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940" title="Reshape. " alt="" coords="164,5,263,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9e549f73a22004d7868a2392fcddae5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1 , typename Derived2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived1::Scalar&gt; qpp::comm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commutator. </p>
<p>Commutator <img class="formulaInl" alt="$ [A,B] = AB - BA $" src="form_29.png"/><br />
 Both <em>A</em> and <em>B</em> must be Eigen expressions over the same scalar field</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">B</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Commutator <img class="formulaInl" alt="$AB -BA$" src="form_30.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a9e549f73a22004d7868a2392fcddae5f_cgraph.png" border="0" usemap="#namespaceqpp_a9e549f73a22004d7868a2392fcddae5f_cgraph" alt=""/></div>
<map name="namespaceqpp_a9e549f73a22004d7868a2392fcddae5f_cgraph" id="namespaceqpp_a9e549f73a22004d7868a2392fcddae5f_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="137,5,272,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="137,71,272,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac0ff84d3dba1a25530b8118e1feb39d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; qpp::compperm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose permutations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
    <tr><td class="paramname">sigma</td><td>Permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Composition of the permutations <em>perm</em> <img class="formulaInl" alt="$\circ$" src="form_34.png"/> <em>sigma</em> = perm(sigma) </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ac0ff84d3dba1a25530b8118e1feb39d2_cgraph.png" border="0" usemap="#namespaceqpp_ac0ff84d3dba1a25530b8118e1feb39d2_cgraph" alt=""/></div>
<map name="namespaceqpp_ac0ff84d3dba1a25530b8118e1feb39d2_cgraph" id="namespaceqpp_ac0ff84d3dba1a25530b8118e1feb39d2_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#ad74950dff6c5fa14902ff599e56f1960" title="qpp::internal::_check_perm" alt="" coords="164,5,335,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::concurrence </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wootters concurrence of the bi-partite qubit mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wootters concurrence </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b_cgraph.png" border="0" usemap="#namespaceqpp_a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b_cgraph" alt=""/></div>
<map name="namespaceqpp_a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b_cgraph" id="namespaceqpp_a6f899cb6e3ea3a13ffd3d8cf0a0bcc6b_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="409,152,544,193"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="409,9,544,50"/><area shape="rect" id="node4" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802" title="qpp::internal::Singleton\l\&lt; const Gates \&gt;::get_instance" alt="" coords="171,93,361,134"/><area shape="rect" id="node5" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="225,42,307,68"/><area shape="rect" id="node6" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7" title="Kronecker product (variadic overload) " alt="" coords="229,210,303,236"/><area shape="rect" id="node7" href="namespaceqpp.html#acbf2df9d3f5c18623eab26ab84ea7418" title="Complex conjugate. " alt="" coords="213,159,319,186"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acbf2df9d3f5c18623eab26ab84ea7418"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::conjugate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex conjugate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex conjugate of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_acbf2df9d3f5c18623eab26ab84ea7418_cgraph.png" border="0" usemap="#namespaceqpp_acbf2df9d3f5c18623eab26ab84ea7418_cgraph" alt=""/></div>
<map name="namespaceqpp_acbf2df9d3f5c18623eab26ab84ea7418_cgraph" id="namespaceqpp_acbf2df9d3f5c18623eab26ab84ea7418_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="160,5,295,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1511e4d5c07691627c88e66070873b1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::contfrac2x </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real representation of a simple continued fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>Integer vector containing the simple continued fraction expansion </td></tr>
    <tr><td class="paramname">n</td><td>Number of terms considered in the continued fraction expansion. If <em>n</em> is greater than the size of <em>cf</em>, then all terms in <em>cf</em> are considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real representation of the simple continued fraction </dd></dl>

</div>
</div>
<a class="anchor" id="a155296775ac0c0cd0cfe52c2ade8f14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::contfrac2x </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real representation of a simple continued fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>Integer vector containing the simple continued fraction expansion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Real representation of the simple continued fraction </dd></dl>

</div>
</div>
<a class="anchor" id="a369c7a2f9f27121178519ddba186fbcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::cosm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix cos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix cosine of <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a369c7a2f9f27121178519ddba186fbcd_cgraph.png" border="0" usemap="#namespaceqpp_a369c7a2f9f27121178519ddba186fbcd_cgraph" alt=""/></div>
<map name="namespaceqpp_a369c7a2f9f27121178519ddba186fbcd_cgraph" id="namespaceqpp_a369c7a2f9f27121178519ddba186fbcd_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="397,12,532,53"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="397,113,532,154"/><area shape="rect" id="node4" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="135,70,213,96"/><area shape="rect" id="node5" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="261,95,349,122"/><area shape="rect" id="node6" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="264,44,347,71"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af68a93794f1719077733b79cc9f2f1df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputScalar , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;OutputScalar&gt; qpp::cwise </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputScalar(*)(const typename Derived::Scalar &amp;)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">f</td><td>Pointer-to-function from scalars of <em>A</em> to <em>OutputScalar</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Component-wise <img class="formulaInl" alt="$f(A)$" src="form_24.png"/>, as a dynamic matrix over the <em>OutputScalar</em> scalar field </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_af68a93794f1719077733b79cc9f2f1df_cgraph.png" border="0" usemap="#namespaceqpp_af68a93794f1719077733b79cc9f2f1df_cgraph" alt=""/></div>
<map name="namespaceqpp_af68a93794f1719077733b79cc9f2f1df_cgraph" id="namespaceqpp_af68a93794f1719077733b79cc9f2f1df_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="137,5,272,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4f6e426d47b5bf66afc0f7cc0321e0eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::det </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determinant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determinant of <em>A</em>, as a scalar in the same scalar field as <em>A</em> Returns <img class="formulaInl" alt="$\pm \infty$" src="form_23.png"/> when the determinant overflows/underflows </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a4f6e426d47b5bf66afc0f7cc0321e0eb_cgraph.png" border="0" usemap="#namespaceqpp_a4f6e426d47b5bf66afc0f7cc0321e0eb_cgraph" alt=""/></div>
<map name="namespaceqpp_a4f6e426d47b5bf66afc0f7cc0321e0eb_cgraph" id="namespaceqpp_a4f6e426d47b5bf66afc0f7cc0321e0eb_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="121,5,256,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4f1805e175751ef749374e3c8499f15d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a> qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chop</em> = <code><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen expression ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">chop</td><td>Set to zero the elements smaller in absolute value than <em>chop</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipEigen </dd></dl>

</div>
</div>
<a class="anchor" id="a815b8e5cf5cd3ab4c463bf53eb550dbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_eigen.html">internal::IOManipEigen</a> qpp::disp </td>
          <td>(</td>
          <td class="paramtype">cplx&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chop</em> = <code><a class="el" href="namespaceqpp.html#a3a6d2c509bdcf240869e1bebb3be4e94">qpp::chop</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex number ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>Complex number (or any other type implicitly cast-able to std::complex&lt;double&gt;) </td></tr>
    <tr><td class="paramname">chop</td><td>Set to zero the elements smaller in absolute value than <em>chop</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipEigen </dd></dl>

</div>
</div>
<a class="anchor" id="a60298648d39542ac44effa9fe73d41c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a>&lt;InputIterator&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipRange </dd></dl>

</div>
</div>
<a class="anchor" id="afc2ad6985e72b70282708a637cf42e7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_range.html">internal::IOManipRange</a>&lt;typename Container::const_iterator&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard container ostream manipulator. The container must support std::begin(), std::end() and forward iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Container </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipRange </dd></dl>

</div>
</div>
<a class="anchor" id="af6e8f13a0bb318a28e1066a8fe5b3ce0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1internal_1_1_i_o_manip_pointer.html">internal::IOManipPointer</a>&lt;PointerType&gt; qpp::disp </td>
          <td>(</td>
          <td class="paramtype">const PointerType *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em> = <code>&quot;[&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em> = <code>&quot;]&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-style pointer ostream manipulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the first element </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to be displayed </td></tr>
    <tr><td class="paramname">separator</td><td>Separator </td></tr>
    <tr><td class="paramname">start</td><td>Left marking </td></tr>
    <tr><td class="paramname">end</td><td>Right marking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instance of qpp::internal::internal::IOManipPointer </dd></dl>

</div>
</div>
<a class="anchor" id="a37e461b037fcb585462fa4556d792e45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::entanglement </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entanglement of the bi-partite pure state <em>A</em>. </p>
<p>Defined as the von-Neumann entropy of the reduced density matrix of one of the subsystems </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a3642532b9a23be1c7f7cafa4629e6d5d" title="Shannon/von-Neumann entropy of the probability distribution/density matrix A. ">qpp::shannon()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Entanglement, with the logarithm in base 2 </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a37e461b037fcb585462fa4556d792e45_cgraph.png" border="0" usemap="#namespaceqpp_a37e461b037fcb585462fa4556d792e45_cgraph" alt=""/></div>
<map name="namespaceqpp_a37e461b037fcb585462fa4556d792e45_cgraph" id="namespaceqpp_a37e461b037fcb585462fa4556d792e45_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="529,399,664,440"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="347,224,481,265"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="347,289,481,331"/><area shape="rect" id="node5" href="namespaceqpp.html#a3642532b9a23be1c7f7cafa4629e6d5d" title="Shannon/von&#45;Neumann entropy of the probability distribution/density matrix A. " alt="" coords="189,122,290,149"/><area shape="rect" id="node9" href="namespaceqpp.html#ad23896bc52b516135d0ce545f8149bfc" title="Schmidt probabilities of the bi&#45;partite pure state A. " alt="" coords="180,355,299,382"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#ad27f82cc41710292417948f5f4b91999" title="qpp::internal::_check\l_vector" alt="" coords="347,5,481,47"/><area shape="rect" id="node7" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="529,115,664,156"/><area shape="rect" id="node8" href="namespaceqpp.html#a96eb6e12c5bc0c544663f6705bc1c950" title="Hermitian eigenvalues. " alt="" coords="369,122,459,149"/><area shape="rect" id="node10" href="namespaceqpp.html#a7b652e3ea4b9748204359a69588a8c91" title="Transpose. " alt="" coords="360,507,468,534"/><area shape="rect" id="node11" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940" title="Reshape. " alt="" coords="365,406,463,433"/><area shape="rect" id="node12" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="371,355,457,382"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a927d85e57656ffb19ddb149985fa52df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt; qpp::evals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvalues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of <em>A</em>, as a complex dynamic column vector </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a927d85e57656ffb19ddb149985fa52df_cgraph.png" border="0" usemap="#namespaceqpp_a927d85e57656ffb19ddb149985fa52df_cgraph" alt=""/></div>
<map name="namespaceqpp_a927d85e57656ffb19ddb149985fa52df_cgraph" id="namespaceqpp_a927d85e57656ffb19ddb149985fa52df_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="136,5,271,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="136,71,271,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acc9597bacc39c501eb8e2e5e8530fcd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::evects </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigenvectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvectors of <em>A</em>, as columns of a complex matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_acc9597bacc39c501eb8e2e5e8530fcd8_cgraph.png" border="0" usemap="#namespaceqpp_acc9597bacc39c501eb8e2e5e8530fcd8_cgraph" alt=""/></div>
<map name="namespaceqpp_acc9597bacc39c501eb8e2e5e8530fcd8_cgraph" id="namespaceqpp_acc9597bacc39c501eb8e2e5e8530fcd8_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="141,5,276,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="141,71,276,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6855dd77c49ae0b96baf10c12b4bc722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::expm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix exponential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix exponential of <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a6855dd77c49ae0b96baf10c12b4bc722_cgraph.png" border="0" usemap="#namespaceqpp_a6855dd77c49ae0b96baf10c12b4bc722_cgraph" alt=""/></div>
<map name="namespaceqpp_a6855dd77c49ae0b96baf10c12b4bc722_cgraph" id="namespaceqpp_a6855dd77c49ae0b96baf10c12b4bc722_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="399,11,533,53"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="399,113,533,154"/><area shape="rect" id="node4" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="136,69,215,96"/><area shape="rect" id="node5" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="263,95,351,121"/><area shape="rect" id="node6" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="265,44,348,71"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a659b50e01fa0b26089d3944c2c56601a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::funm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cplx(*)(const cplx &amp;)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functional calculus f(A) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">f</td><td>Pointer-to-function from complex to complex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em><img class="formulaInl" alt="$f(A)$" src="form_24.png"/></em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a659b50e01fa0b26089d3944c2c56601a_cgraph.png" border="0" usemap="#namespaceqpp_a659b50e01fa0b26089d3944c2c56601a_cgraph" alt=""/></div>
<map name="namespaceqpp_a659b50e01fa0b26089d3944c2c56601a_cgraph" id="namespaceqpp_a659b50e01fa0b26089d3944c2c56601a_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="268,11,403,52"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="268,76,403,117"/><area shape="rect" id="node4" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="132,25,220,51"/><area shape="rect" id="node5" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="135,75,217,102"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae245a12a1f7c9ab36da26498b2c4da96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::gcd </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greatest common divisor of two non-negative integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Non-negative integer </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest common divisor of <em>m</em> and <em>n</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6b06a1ed3f09f5296470d4c180d9edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::gcd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Greatest common divisor of a list of non-negative integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>List of non-negative integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Greatest common divisor of all numbers in <em>ns</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ac6b06a1ed3f09f5296470d4c180d9edc_cgraph.png" border="0" usemap="#namespaceqpp_ac6b06a1ed3f09f5296470d4c180d9edc_cgraph" alt=""/></div>
<map name="namespaceqpp_ac6b06a1ed3f09f5296470d4c180d9edc_cgraph" id="namespaceqpp_ac6b06a1ed3f09f5296470d4c180d9edc_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#ae245a12a1f7c9ab36da26498b2c4da96" title="Greatest common divisor of two non&#45;negative integers. " alt="" coords="124,5,195,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a100bf63d3dabba74e049aff37ea7e383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::gconcurrence </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>G-concurrence of the bi-partite pure state <em>A</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Both local dimensions must be equal</dd></dl>
<p>Uses <a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183" title="Logarithm of the determinant. ">qpp::logdet()</a> to avoid overflows </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183" title="Logarithm of the determinant. ">qpp::logdet()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>G-concurrence </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a100bf63d3dabba74e049aff37ea7e383_cgraph.png" border="0" usemap="#namespaceqpp_a100bf63d3dabba74e049aff37ea7e383_cgraph" alt=""/></div>
<map name="namespaceqpp_a100bf63d3dabba74e049aff37ea7e383_cgraph" id="namespaceqpp_a100bf63d3dabba74e049aff37ea7e383_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="360,82,495,123"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="177,31,312,72"/><area shape="rect" id="node4" href="namespaceqpp.html#a95a129545b05e69dd7f4c60b009ca183" title="Logarithm of the determinant. " alt="" coords="203,148,287,174"/><area shape="rect" id="node6" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940" title="Reshape. " alt="" coords="195,97,294,124"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="360,147,495,188"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a743da9600f080b2d31951a91b0e2e59a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization (std::vector overload) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vs</td><td>std::vector of Eigen expressions as column vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of <em>Vs</em> as columns of a dynamic matrix over the same scalar field as its arguments </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a743da9600f080b2d31951a91b0e2e59a_cgraph.png" border="0" usemap="#namespaceqpp_a743da9600f080b2d31951a91b0e2e59a_cgraph" alt=""/></div>
<map name="namespaceqpp_a743da9600f080b2d31951a91b0e2e59a_cgraph" id="namespaceqpp_a743da9600f080b2d31951a91b0e2e59a_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="436,140,571,181"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="253,5,388,47"/><area shape="rect" id="node4" href="namespaceqpp.html#af2e4740854c958579228593dd639aa6c" title="Frobenius norm. " alt="" coords="281,173,360,199"/><area shape="rect" id="node5" href="namespaceqpp.html#a4324f5182395adab0e36eede35e4fe6b" title="Projector. " alt="" coords="140,122,205,149"/><area shape="rect" id="node6" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="277,122,365,149"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad478cc51fbe3e7843460f54eecb0f726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization (std::initializer_list overload) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vs</td><td>std::initializer_list of Eigen expressions as column vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of <em>Vs</em> as columns of a dynamic matrix over the same scalar field as its arguments </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ad478cc51fbe3e7843460f54eecb0f726_cgraph.png" border="0" usemap="#namespaceqpp_ad478cc51fbe3e7843460f54eecb0f726_cgraph" alt=""/></div>
<map name="namespaceqpp_ad478cc51fbe3e7843460f54eecb0f726_cgraph" id="namespaceqpp_ad478cc51fbe3e7843460f54eecb0f726_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a743da9600f080b2d31951a91b0e2e59a" title="Gram&#45;Schmidt orthogonalization (std::vector overload) " alt="" coords="140,147,227,174"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="571,140,705,181"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="388,5,523,47"/><area shape="rect" id="node5" href="namespaceqpp.html#af2e4740854c958579228593dd639aa6c" title="Frobenius norm. " alt="" coords="416,173,495,199"/><area shape="rect" id="node6" href="namespaceqpp.html#a4324f5182395adab0e36eede35e4fe6b" title="Projector. " alt="" coords="275,122,340,149"/><area shape="rect" id="node7" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="411,122,499,149"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a46120dde34a67d551a3e118f908fdcd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::grams </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gram-Schmidt orthogonalization (Eigen expression (matrix) overload) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, the input vectors are the columns of <em>A</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gram-Schmidt vectors of the columns of <em>A</em>, as columns of a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a46120dde34a67d551a3e118f908fdcd1_cgraph.png" border="0" usemap="#namespaceqpp_a46120dde34a67d551a3e118f908fdcd1_cgraph" alt=""/></div>
<map name="namespaceqpp_a46120dde34a67d551a3e118f908fdcd1_cgraph" id="namespaceqpp_a46120dde34a67d551a3e118f908fdcd1_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="140,5,275,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a96eb6e12c5bc0c544663f6705bc1c950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;double&gt; qpp::hevals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hermitian eigenvalues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvalues of Hermitian <em>A</em>, as a real dynamic column vector </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a96eb6e12c5bc0c544663f6705bc1c950_cgraph.png" border="0" usemap="#namespaceqpp_a96eb6e12c5bc0c544663f6705bc1c950_cgraph" alt=""/></div>
<map name="namespaceqpp_a96eb6e12c5bc0c544663f6705bc1c950_cgraph" id="namespaceqpp_a96eb6e12c5bc0c544663f6705bc1c950_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="143,5,277,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="143,71,277,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abeadaf6395c78a52339bec119c4a331b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::hevects </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hermitian eigenvectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigenvectors of Hermitian <em>A</em>, as columns of a complex matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_abeadaf6395c78a52339bec119c4a331b_cgraph.png" border="0" usemap="#namespaceqpp_abeadaf6395c78a52339bec119c4a331b_cgraph" alt=""/></div>
<map name="namespaceqpp_abeadaf6395c78a52339bec119c4a331b_cgraph" id="namespaceqpp_abeadaf6395c78a52339bec119c4a331b_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="148,5,283,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="148,71,283,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4ba74531ce09b81f5ea1afbb9c94a6de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::inverse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a4ba74531ce09b81f5ea1afbb9c94a6de_cgraph.png" border="0" usemap="#namespaceqpp_a4ba74531ce09b81f5ea1afbb9c94a6de_cgraph" alt=""/></div>
<map name="namespaceqpp_a4ba74531ce09b81f5ea1afbb9c94a6de_cgraph" id="namespaceqpp_a4ba74531ce09b81f5ea1afbb9c94a6de_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="144,5,279,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6a2093db36b11503a66f77301fbbedb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; qpp::invperm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse permutation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inverse of the permutation <em>perm</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a6a2093db36b11503a66f77301fbbedb5_cgraph.png" border="0" usemap="#namespaceqpp_a6a2093db36b11503a66f77301fbbedb5_cgraph" alt=""/></div>
<map name="namespaceqpp_a6a2093db36b11503a66f77301fbbedb5_cgraph" id="namespaceqpp_a6a2093db36b11503a66f77301fbbedb5_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#ad74950dff6c5fa14902ff599e56f1960" title="qpp::internal::_check_perm" alt="" coords="148,5,319,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3b2bafdce8302c9ac34ab328ec84a3f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename T::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product (variadic overload) </p>
<p>Used to stop the recursion for the variadic template version of <a class="el" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7" title="Kronecker product (variadic overload) ">qpp::kron()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Its argument <em>head</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a9cf9a3f8918581dc2f6cc4972e22402e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename T::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product (variadic overload) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">tail</td><td>Variadic Eigen expression (zero or more parameters) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all input parameters, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a9cf9a3f8918581dc2f6cc4972e22402e_cgraph.png" border="0" usemap="#namespaceqpp_a9cf9a3f8918581dc2f6cc4972e22402e_cgraph" alt=""/></div>
<map name="namespaceqpp_a9cf9a3f8918581dc2f6cc4972e22402e_cgraph" id="namespaceqpp_a9cf9a3f8918581dc2f6cc4972e22402e_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#acc7ac24af699fa7185410195c7a8bb9c" title="qpp::internal::_kron2" alt="" coords="128,13,261,39"/><area shape="rect" id="node4" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7" title="Kronecker product (variadic overload) " alt="" coords="157,63,232,90"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="309,5,444,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aec55628dde4007629317cfa104b1073f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product (std::vector overload) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::vector of Eigen expressions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all elements in <em>As</em>, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_aec55628dde4007629317cfa104b1073f_cgraph.png" border="0" usemap="#namespaceqpp_aec55628dde4007629317cfa104b1073f_cgraph" alt=""/></div>
<map name="namespaceqpp_aec55628dde4007629317cfa104b1073f_cgraph" id="namespaceqpp_aec55628dde4007629317cfa104b1073f_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7" title="Kronecker product (variadic overload) " alt="" coords="128,5,203,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad11c7ebe19908ccaafbf5471f60926c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::kron </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>As</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker product (std::initializer_list overload) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">As</td><td>std::initializer_list of Eigen expressions, such as <em>{A1</em>, A2, ... ,Ak} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of all elements in <em>As</em>, evaluated from left to right, as a dynamic matrix over the same scalar field as its arguments </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ad11c7ebe19908ccaafbf5471f60926c7_cgraph.png" border="0" usemap="#namespaceqpp_ad11c7ebe19908ccaafbf5471f60926c7_cgraph" alt=""/></div>
<map name="namespaceqpp_ad11c7ebe19908ccaafbf5471f60926c7_cgraph" id="namespaceqpp_ad11c7ebe19908ccaafbf5471f60926c7_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7" title="Kronecker product (variadic overload) " alt="" coords="128,5,203,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac695bd8e27cfe03265b550f62c394adb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::kronpow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kronecker power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker product of <em>A</em> with itself <em>n</em> times <img class="formulaInl" alt="$A^{\otimes n}$" src="form_28.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ac695bd8e27cfe03265b550f62c394adb_cgraph.png" border="0" usemap="#namespaceqpp_ac695bd8e27cfe03265b550f62c394adb_cgraph" alt=""/></div>
<map name="namespaceqpp_ac695bd8e27cfe03265b550f62c394adb_cgraph" id="namespaceqpp_ac695bd8e27cfe03265b550f62c394adb_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="153,5,288,47"/><area shape="rect" id="node3" href="namespaceqpp.html#a3b2bafdce8302c9ac34ab328ec84a3f7" title="Kronecker product (variadic overload) " alt="" coords="183,71,258,98"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a37ded4330bac75ed34190b1c40d53381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::lcm </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Least common multiple of two positive integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Positive integer </td></tr>
    <tr><td class="paramname">n</td><td>Positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Least common multiple of <em>m</em> and <em>n</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a37ded4330bac75ed34190b1c40d53381_cgraph.png" border="0" usemap="#namespaceqpp_a37ded4330bac75ed34190b1c40d53381_cgraph" alt=""/></div>
<map name="namespaceqpp_a37ded4330bac75ed34190b1c40d53381_cgraph" id="namespaceqpp_a37ded4330bac75ed34190b1c40d53381_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#ae245a12a1f7c9ab36da26498b2c4da96" title="Greatest common divisor of two non&#45;negative integers. " alt="" coords="123,5,193,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0cd094d5bde1344756f98167abb079f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::lcm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Least common multiple of a list of positive integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>List of positive integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Least common multiple of all numbers in <em>ns</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a0cd094d5bde1344756f98167abb079f5_cgraph.png" border="0" usemap="#namespaceqpp_a0cd094d5bde1344756f98167abb079f5_cgraph" alt=""/></div>
<map name="namespaceqpp_a0cd094d5bde1344756f98167abb079f5_cgraph" id="namespaceqpp_a0cd094d5bde1344756f98167abb079f5_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a78595ec429a5df51dbe682cdb9711d9c" title="Element&#45;wise product of A. " alt="" coords="123,13,199,39"/><area shape="rect" id="node4" href="namespaceqpp.html#ae245a12a1f7c9ab36da26498b2c4da96" title="Greatest common divisor of two non&#45;negative integers. " alt="" coords="125,63,196,90"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="247,5,381,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a217e8ae6b09ac3cc89415d4b6204fda6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads Eigen matrix from a binary file (internal format) in double precision. </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided, depending on the scalar field of the matrix that is being loaded.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen dynamic complex matrix from &quot;input.bin&quot;</span></div>
<div class="line"><span class="keyword">auto</span> mat = load&lt;cmat&gt;(<span class="stringliteral">&quot;input.bin&quot;</span>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a84a0f3023e1895d22de4e5f3e727e1dd" title="Loads an Eigen dynamic matrix from a MATLAB .mat file, generic version. ">qpp::loadMATLABmatrix()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">fname</td><td>Output file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84a0f3023e1895d22de4e5f3e727e1dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived qpp::loadMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an Eigen dynamic matrix from a MATLAB .mat file, generic version. </p>
<p>This is the generic version that always throws <em><a class="el" href="classqpp_1_1_exception.html#a91985c96dc408d3538b8f88cf1eaae7ca4e1a1a494e699e494ab9368f62629530" title="UNDEFINED_TYPE. ">qpp::Exception::Type::UNDEFINED_TYPE</a></em>. It is specialized only for <em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em> and <em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em> (the only matrix types that can be loaded) </p>

</div>
</div>
<a class="anchor" id="aa2030161b0158746beaac80612a3464e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> qpp::loadMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads an Eigen dynamic matrix from a MATLAB .mat file, specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen dynamic double matrix from the</span></div>
<div class="line">MATLAB file <span class="stringliteral">&quot;input.mat&quot;</span></div>
<div class="line"><span class="keyword">auto</span> mat = loadMATLABmatrix&lt;dmat&gt;(<span class="stringliteral">&quot;input.mat&quot;</span>);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If <em>var_name</em> is a complex matrix, only the real part is loaded</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen double dynamic matrix (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </dd></dl>

</div>
</div>
<a class="anchor" id="a26858bfbbec50369d19270c7bf329afa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::loadMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads an Eigen dynamic matrix from a MATLAB .mat file, specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// loads a previously saved Eigen dynamic complex matrix from the</span></div>
<div class="line">MATLAB file <span class="stringliteral">&quot;input.mat&quot;</span></div>
<div class="line"><span class="keyword">auto</span> mat = loadMATLABmatrix&lt;cmat&gt;(<span class="stringliteral">&quot;input.mat&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be loaded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen complex dynamic matrix (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </dd></dl>

</div>
</div>
<a class="anchor" id="a95a129545b05e69dd7f4c60b009ca183"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::logdet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logarithm of the determinant. </p>
<p>Especially useful when the determinant overflows/underflows<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logarithm of the determinant of <em>A</em>, as a scalar in the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a95a129545b05e69dd7f4c60b009ca183_cgraph.png" border="0" usemap="#namespaceqpp_a95a129545b05e69dd7f4c60b009ca183_cgraph" alt=""/></div>
<map name="namespaceqpp_a95a129545b05e69dd7f4c60b009ca183_cgraph" id="namespaceqpp_a95a129545b05e69dd7f4c60b009ca183_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="137,5,272,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="137,71,272,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a683ff6f7df206be1a6105317c4c8ed70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::logm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix logarithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix logarithm of <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a683ff6f7df206be1a6105317c4c8ed70_cgraph.png" border="0" usemap="#namespaceqpp_a683ff6f7df206be1a6105317c4c8ed70_cgraph" alt=""/></div>
<map name="namespaceqpp_a683ff6f7df206be1a6105317c4c8ed70_cgraph" id="namespaceqpp_a683ff6f7df206be1a6105317c4c8ed70_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="393,12,528,53"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="393,113,528,154"/><area shape="rect" id="node4" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="131,70,209,96"/><area shape="rect" id="node5" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="257,95,345,122"/><area shape="rect" id="node6" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="260,44,343,71"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aba8b627b60cfe29f6062776d088cb889"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::lognegativity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logarithmic negativity of the bi-partite mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Logarithmic negativity, with the logarithm in base 2 </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_aba8b627b60cfe29f6062776d088cb889_cgraph.png" border="0" usemap="#namespaceqpp_aba8b627b60cfe29f6062776d088cb889_cgraph" alt=""/></div>
<map name="namespaceqpp_aba8b627b60cfe29f6062776d088cb889_cgraph" id="namespaceqpp_aba8b627b60cfe29f6062776d088cb889_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="1107,593,1241,634"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="1107,187,1241,229"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="506,363,641,405"/><area shape="rect" id="node5" href="namespaceqpp.html#ae5ecdcfef5ce5a89efbebf0f4354be36" title="Negativity of the bi&#45;partite mixed state A. " alt="" coords="173,404,277,431"/><area shape="rect" id="node6" href="namespaceqpp.html#a8251985eb390022a0116f6572a82ea58" title="Schatten norm. " alt="" coords="334,651,433,677"/><area shape="rect" id="node16" href="namespaceqpp.html#a0893a2a4dcfd11696a0e675da03f8f61" title="Partial transpose. " alt="" coords="325,236,441,263"/><area shape="rect" id="node7" href="namespaceqpp.html#a51e1199f56fdc39622a17c949d6ede5a" title="Singular values. " alt="" coords="837,701,920,728"/><area shape="rect" id="node8" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54" title="Trace. " alt="" coords="707,752,785,779"/><area shape="rect" id="node9" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="971,245,1058,272"/><area shape="rect" id="node10" href="namespaceqpp.html#a3a4cb16d97f9cc763bd133b64f2b6f6d" title="Matrix absolut value. " alt="" coords="531,600,615,627"/><area shape="rect" id="node11" href="namespaceqpp.html#a83e2b23bc11e3cb8dd6909969af7377c" title="Matrix square root. " alt="" coords="705,423,787,449"/><area shape="rect" id="node15" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="835,600,923,627"/><area shape="rect" id="node12" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="839,397,918,424"/><area shape="rect" id="node13" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="971,397,1059,424"/><area shape="rect" id="node14" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="973,347,1056,373"/><area shape="rect" id="node17" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="489,261,657,288"/><area shape="rect" id="node18" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="500,94,647,135"/><area shape="rect" id="node19" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="495,160,652,187"/><area shape="rect" id="node20" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="495,211,652,237"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a27f5cf97f5ee0fbdeae163c0f77e28d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of vector of probabilities and vector of post-measurement normalized states </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a27f5cf97f5ee0fbdeae163c0f77e28d6_cgraph.png" border="0" usemap="#namespaceqpp_a27f5cf97f5ee0fbdeae163c0f77e28d6_cgraph" alt=""/></div>
<map name="namespaceqpp_a27f5cf97f5ee0fbdeae163c0f77e28d6_cgraph" id="namespaceqpp_a27f5cf97f5ee0fbdeae163c0f77e28d6_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="336,93,471,134"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="153,34,288,75"/><area shape="rect" id="node4" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="177,100,265,127"/><area shape="rect" id="node5" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54" title="Trace. " alt="" coords="181,151,260,177"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="153,202,288,243"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a06e3ae31fe7cd58136a4072dcfc389e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> using the set of Kraus operators <em>Ks</em> (std::initializer_list overload) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of vector of probabilities and vector of post-measurement normalized states </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a06e3ae31fe7cd58136a4072dcfc389e9_cgraph.png" border="0" usemap="#namespaceqpp_a06e3ae31fe7cd58136a4072dcfc389e9_cgraph" alt=""/></div>
<map name="namespaceqpp_a06e3ae31fe7cd58136a4072dcfc389e9_cgraph" id="namespaceqpp_a06e3ae31fe7cd58136a4072dcfc389e9_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a27f5cf97f5ee0fbdeae163c0f77e28d6" title="Measures the state A using the set of Kraus operators Ks. " alt="" coords="153,100,253,127"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="484,93,619,134"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="301,34,436,75"/><area shape="rect" id="node5" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="325,100,413,127"/><area shape="rect" id="node6" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54" title="Trace. " alt="" coords="329,151,408,177"/><area shape="rect" id="node7" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="301,202,436,243"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6bb62ddad1b66794b3cfd74d80f8aaf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; &gt; qpp::measure </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cmat &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the state <em>A</em> in the orthonormal basis specified by the eigenvectors of <em>M</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">M</td><td>Normal matrix whose eigenvectors define the measurement basis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of vector of probabilities and vector of post-measurement normalized states </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a6bb62ddad1b66794b3cfd74d80f8aaf9_cgraph.png" border="0" usemap="#namespaceqpp_a6bb62ddad1b66794b3cfd74d80f8aaf9_cgraph" alt=""/></div>
<map name="namespaceqpp_a6bb62ddad1b66794b3cfd74d80f8aaf9_cgraph" id="namespaceqpp_a6bb62ddad1b66794b3cfd74d80f8aaf9_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="472,217,607,258"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="289,99,424,141"/><area shape="rect" id="node4" href="namespaceqpp.html#a4324f5182395adab0e36eede35e4fe6b" title="Projector. " alt="" coords="165,283,230,309"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="289,217,424,258"/><area shape="rect" id="node7" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="313,384,401,411"/><area shape="rect" id="node8" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="153,64,241,91"/><area shape="rect" id="node9" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54" title="Trace. " alt="" coords="158,5,237,32"/><area shape="rect" id="node6" href="namespaceqpp.html#af2e4740854c958579228593dd639aa6c" title="Frobenius norm. " alt="" coords="317,333,396,360"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a94ade48c09bb33df893d7ff62a098374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a> qpp::mket </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-partite qudit ket (different dimensions overload) </p>
<p>Constructs the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_33.png"/>, where <em>mask</em> is a std::vector of non-negative integers<br />
Each element in <em>mask</em> has to be smaller than the corresponding element in <em>dims</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-partite qudit state vector, as a complex dynamic column vector </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a94ade48c09bb33df893d7ff62a098374_cgraph.png" border="0" usemap="#namespaceqpp_a94ade48c09bb33df893d7ff62a098374_cgraph" alt=""/></div>
<map name="namespaceqpp_a94ade48c09bb33df893d7ff62a098374_cgraph" id="namespaceqpp_a94ade48c09bb33df893d7ff62a098374_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="284,5,452,32"/><area shape="rect" id="node3" href="namespaceqpp.html#a19badf6efe78383485b2ba28e4136bb7" title="Multi&#45;index to non&#45;negative integer index. " alt="" coords="131,56,236,83"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="289,56,447,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab7b2d9874a3688fbb56eaff32f9acc7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a> qpp::mket </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-partite qudit ket (same dimensions overload) </p>
<p>Constructs the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_33.png"/>, all subsystem having equal dimension <em>d</em> <br />
<em>mask</em> is a std::vector of non-negative integers, and each element in <em>mask</em> has to be strictly smaller than <em>d</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">d</td><td>Subsystems' dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-partite qudit state vector, as a complex dynamic column vector </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ab7b2d9874a3688fbb56eaff32f9acc7d_cgraph.png" border="0" usemap="#namespaceqpp_ab7b2d9874a3688fbb56eaff32f9acc7d_cgraph" alt=""/></div>
<map name="namespaceqpp_ab7b2d9874a3688fbb56eaff32f9acc7d_cgraph" id="namespaceqpp_ab7b2d9874a3688fbb56eaff32f9acc7d_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a19badf6efe78383485b2ba28e4136bb7" title="Multi&#45;index to non&#45;negative integer index. " alt="" coords="131,31,236,57"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="284,5,452,32"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="289,56,447,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af881bc85f432ae9ee8a41a34b9ffae07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::mprj </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projector onto multi-partite qudit ket (different dimensions overload) </p>
<p>Constructs the projector onto the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_33.png"/>, where <em>mask</em> is a std::vector of non-negative integers<br />
Each element in <em>mask</em> has to be smaller than the corresponding element in <em>dims</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto multi-partite qudit state vector, as a complex dynamic matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_af881bc85f432ae9ee8a41a34b9ffae07_cgraph.png" border="0" usemap="#namespaceqpp_af881bc85f432ae9ee8a41a34b9ffae07_cgraph" alt=""/></div>
<map name="namespaceqpp_af881bc85f432ae9ee8a41a34b9ffae07_cgraph" id="namespaceqpp_af881bc85f432ae9ee8a41a34b9ffae07_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="281,5,449,32"/><area shape="rect" id="node3" href="namespaceqpp.html#a19badf6efe78383485b2ba28e4136bb7" title="Multi&#45;index to non&#45;negative integer index. " alt="" coords="128,56,233,83"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="287,56,444,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a933550ccd7424593b89a7682469f3fed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::mprj </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>d</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projector onto multi-partite qudit ket (same dimensions overload) </p>
<p>Constructs the projector onto the multi-partite qudit ket <img class="formulaInl" alt="$|\mathrm{mask}\rangle$" src="form_33.png"/>, all subsystem having equal dimension <em>d</em> <br />
<em>mask</em> is a std::vector of non-negative integers, and each element in <em>mask</em> has to be strictly smaller than <em>d</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>std::vector of non-negative integers </td></tr>
    <tr><td class="paramname">d</td><td>Subsystems' dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto multi-partite qudit state vector, as a complex dynamic matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a933550ccd7424593b89a7682469f3fed_cgraph.png" border="0" usemap="#namespaceqpp_a933550ccd7424593b89a7682469f3fed_cgraph" alt=""/></div>
<map name="namespaceqpp_a933550ccd7424593b89a7682469f3fed_cgraph" id="namespaceqpp_a933550ccd7424593b89a7682469f3fed_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a19badf6efe78383485b2ba28e4136bb7" title="Multi&#45;index to non&#45;negative integer index. " alt="" coords="128,31,233,57"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="281,5,449,32"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="287,56,444,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a19badf6efe78383485b2ba28e4136bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t qpp::multiidx2n </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>midx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-index to non-negative integer index. </p>
<p>Uses standard lexicographical order, i.e. 00...0, 00...1 etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">midx</td><td>Multi-index </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative integer index </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a19badf6efe78383485b2ba28e4136bb7_cgraph.png" border="0" usemap="#namespaceqpp_a19badf6efe78383485b2ba28e4136bb7_cgraph" alt=""/></div>
<map name="namespaceqpp_a19badf6efe78383485b2ba28e4136bb7_cgraph" id="namespaceqpp_a19badf6efe78383485b2ba28e4136bb7_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="159,5,327,32"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="164,56,321,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="afbe051c49a6c9c5a1cbb6401f95143a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; qpp::n2multiidx </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-negative integer index to multi-index. </p>
<p>Uses standard lexicographical order, i.e. 00...0, 00...1 etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Non-negative integer index </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Multi-index of the same size as <em>dims</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_afbe051c49a6c9c5a1cbb6401f95143a8_cgraph.png" border="0" usemap="#namespaceqpp_afbe051c49a6c9c5a1cbb6401f95143a8_cgraph" alt=""/></div>
<map name="namespaceqpp_afbe051c49a6c9c5a1cbb6401f95143a8_cgraph" id="namespaceqpp_afbe051c49a6c9c5a1cbb6401f95143a8_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="159,5,327,32"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="164,56,321,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae5ecdcfef5ce5a89efbebf0f4354be36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::negativity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negativity of the bi-partite mixed state <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negativity </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ae5ecdcfef5ce5a89efbebf0f4354be36_cgraph.png" border="0" usemap="#namespaceqpp_ae5ecdcfef5ce5a89efbebf0f4354be36_cgraph" alt=""/></div>
<map name="namespaceqpp_ae5ecdcfef5ce5a89efbebf0f4354be36_cgraph" id="namespaceqpp_ae5ecdcfef5ce5a89efbebf0f4354be36_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="939,263,1073,305"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="939,618,1073,659"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="338,782,473,823"/><area shape="rect" id="node5" href="namespaceqpp.html#a8251985eb390022a0116f6572a82ea58" title="Schatten norm. " alt="" coords="166,195,265,221"/><area shape="rect" id="node15" href="namespaceqpp.html#a0893a2a4dcfd11696a0e675da03f8f61" title="Partial transpose. " alt="" coords="157,629,273,656"/><area shape="rect" id="node6" href="namespaceqpp.html#a51e1199f56fdc39622a17c949d6ede5a" title="Singular values. " alt="" coords="669,93,752,120"/><area shape="rect" id="node7" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54" title="Trace. " alt="" coords="539,144,617,171"/><area shape="rect" id="node8" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="803,600,890,627"/><area shape="rect" id="node9" href="namespaceqpp.html#a3a4cb16d97f9cc763bd133b64f2b6f6d" title="Matrix absolut value. " alt="" coords="363,245,447,272"/><area shape="rect" id="node10" href="namespaceqpp.html#a83e2b23bc11e3cb8dd6909969af7377c" title="Matrix square root. " alt="" coords="537,417,619,444"/><area shape="rect" id="node14" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="667,245,755,272"/><area shape="rect" id="node11" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="671,448,750,475"/><area shape="rect" id="node12" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="803,499,891,525"/><area shape="rect" id="node13" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="805,448,888,475"/><area shape="rect" id="node16" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="321,512,489,539"/><area shape="rect" id="node17" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="332,563,479,605"/><area shape="rect" id="node18" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="327,629,484,656"/><area shape="rect" id="node19" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="327,731,484,757"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af2e4740854c958579228593dd639aa6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::norm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frobenius norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frobenius norm of <em>A</em>, as a real number </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_af2e4740854c958579228593dd639aa6c_cgraph.png" border="0" usemap="#namespaceqpp_af2e4740854c958579228593dd639aa6c_cgraph" alt=""/></div>
<map name="namespaceqpp_af2e4740854c958579228593dd639aa6c_cgraph" id="namespaceqpp_af2e4740854c958579228593dd639aa6c_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="132,5,267,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a66175b7225b388d8851c04171fc7a141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt;double&gt; qpp::omega </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>D-th root of unity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>D-th root of unity <img class="formulaInl" alt="$\exp(2\pi i/D)$" src="form_7.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a09fc2700e3012040bfb2f273ea4b79e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::complex&lt;double&gt; qpp::operator&quot;&quot;_i </td>
          <td>(</td>
          <td class="paramtype">unsigned long long int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_4.png"/> (integer overload) </p>
<p>Example:</p><div class="fragment"><div class="line"><span class="keyword">auto</span> z = 4_i; <span class="comment">// type of z is std::complex&lt;double&gt; </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2a3f80a89a7844c88f5bc556d40c4909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::complex&lt;double&gt; qpp::operator&quot;&quot;_i </td>
          <td>(</td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User-defined literal for complex <img class="formulaInl" alt="$i=\sqrt{-1}$" src="form_4.png"/> (real overload) </p>
<p>Example:</p><div class="fragment"><div class="line"><span class="keyword">auto</span> z = 4.5_i; <span class="comment">// type of z is std::complex&lt;double&gt; </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3b4fd08d05e83656e8ce3153fe5a6f0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::powm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix power. </p>
<p>Explicitly multiplies the matrix <em>A</em> with itself <em>n</em> times<br />
By convention <img class="formulaInl" alt="$A^0 = I$" src="form_25.png"/></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">n</td><td>Non-negative integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix power <img class="formulaInl" alt="$A^n$" src="form_27.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a3b4fd08d05e83656e8ce3153fe5a6f0b_cgraph.png" border="0" usemap="#namespaceqpp_a3b4fd08d05e83656e8ce3153fe5a6f0b_cgraph" alt=""/></div>
<map name="namespaceqpp_a3b4fd08d05e83656e8ce3153fe5a6f0b_cgraph" id="namespaceqpp_a3b4fd08d05e83656e8ce3153fe5a6f0b_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="140,5,275,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="140,71,275,112"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4324f5182395adab0e36eede35e4fe6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::prj </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projector. </p>
<p>Normalized projector onto state vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Projector onto the state vector <em>V</em>, or the matrix <em>Zero</em> if <em>V</em> has norm zero (i.e. smaller than <a class="el" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6" title="Used to decide whether a number or expression in double precision is zero or not. ...">qpp::eps</a>), as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a4324f5182395adab0e36eede35e4fe6b_cgraph.png" border="0" usemap="#namespaceqpp_a4324f5182395adab0e36eede35e4fe6b_cgraph" alt=""/></div>
<map name="namespaceqpp_a4324f5182395adab0e36eede35e4fe6b_cgraph" id="namespaceqpp_a4324f5182395adab0e36eede35e4fe6b_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="301,92,436,133"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="119,33,253,74"/><area shape="rect" id="node4" href="namespaceqpp.html#af2e4740854c958579228593dd639aa6c" title="Frobenius norm. " alt="" coords="147,99,225,126"/><area shape="rect" id="node5" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="142,150,230,176"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a78595ec429a5df51dbe682cdb9711d9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::prod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise product of <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise product of <em>A</em>, as a scalar in the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a78595ec429a5df51dbe682cdb9711d9c_cgraph.png" border="0" usemap="#namespaceqpp_a78595ec429a5df51dbe682cdb9711d9c_cgraph" alt=""/></div>
<map name="namespaceqpp_a78595ec429a5df51dbe682cdb9711d9c_cgraph" id="namespaceqpp_a78595ec429a5df51dbe682cdb9711d9c_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="129,5,264,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab7f10cf7a2845946fedfac88e6a9081f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qpp::prod </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename InputIterator::value_type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise product of a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise product of the range, as a scalar in the same scalar field as the range </dd></dl>

</div>
</div>
<a class="anchor" id="a5fef47d40c93533b586f9b90a97c3621"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<p>Partial trace of the multi-partite density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{subsys}(\cdot)$" src="form_42.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a5fef47d40c93533b586f9b90a97c3621_cgraph.png" border="0" usemap="#namespaceqpp_a5fef47d40c93533b586f9b90a97c3621_cgraph" alt=""/></div>
<map name="namespaceqpp_a5fef47d40c93533b586f9b90a97c3621_cgraph" id="namespaceqpp_a5fef47d40c93533b586f9b90a97c3621_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="157,5,291,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="140,71,308,98"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="157,123,291,164"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="157,188,291,229"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="151,253,297,295"/><area shape="rect" id="node7" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="145,319,303,346"/><area shape="rect" id="node8" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="145,370,303,397"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a89291882069b2a76650a082029dc4e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace1 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<p>Partial trace of density matrix over the first subsystem in a bi-partite system</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system (must be a std::vector with 2 elements) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{A}(\cdot)$" src="form_37.png"/> over the first subsytem <img class="formulaInl" alt="$A$" src="form_38.png"/> in a bi-partite system <img class="formulaInl" alt="$A\otimes B$" src="form_39.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a89291882069b2a76650a082029dc4e94_cgraph.png" border="0" usemap="#namespaceqpp_a89291882069b2a76650a082029dc4e94_cgraph" alt=""/></div>
<map name="namespaceqpp_a89291882069b2a76650a082029dc4e94_cgraph" id="namespaceqpp_a89291882069b2a76650a082029dc4e94_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="363,96,497,137"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="147,37,315,63"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="163,88,298,129"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="163,153,298,195"/><area shape="rect" id="node6" href="namespaceqpp.html#a48a92e8a327ff86f87c6236965103797" title="Element&#45;wise sum of A. " alt="" coords="193,219,268,246"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae846df6b2525ef728947e00c2074e8b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptrace2 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial trace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system (must be a std::vector with 2 elements) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial trace <img class="formulaInl" alt="$Tr_{B}(\cdot)$" src="form_40.png"/> over the second subsytem <img class="formulaInl" alt="$B$" src="form_41.png"/> in a bi-partite system <img class="formulaInl" alt="$A\otimes B$" src="form_39.png"/>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ae846df6b2525ef728947e00c2074e8b6_cgraph.png" border="0" usemap="#namespaceqpp_ae846df6b2525ef728947e00c2074e8b6_cgraph" alt=""/></div>
<map name="namespaceqpp_ae846df6b2525ef728947e00c2074e8b6_cgraph" id="namespaceqpp_ae846df6b2525ef728947e00c2074e8b6_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="363,96,497,137"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="147,37,315,63"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="163,88,298,129"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="163,153,298,195"/><area shape="rect" id="node6" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54" title="Trace. " alt="" coords="191,219,270,246"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0893a2a4dcfd11696a0e675da03f8f61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::ptranspose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial transpose. </p>
<p>Partial transpose of the multi-partite density matrix over a list of subsystems</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsys</td><td>Subsystem indexes </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Partial transpose <img class="formulaInl" alt="$(\cdot)^{T_{subsys}}$" src="form_43.png"/> over the subsytems <em>subsys</em> in a multi-partite system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a0893a2a4dcfd11696a0e675da03f8f61_cgraph.png" border="0" usemap="#namespaceqpp_a0893a2a4dcfd11696a0e675da03f8f61_cgraph" alt=""/></div>
<map name="namespaceqpp_a0893a2a4dcfd11696a0e675da03f8f61_cgraph" id="namespaceqpp_a0893a2a4dcfd11696a0e675da03f8f61_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="186,5,321,47"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="169,71,337,98"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="186,123,321,164"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="186,188,321,229"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="180,253,327,295"/><area shape="rect" id="node7" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="175,319,332,346"/><area shape="rect" id="node8" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="175,370,332,397"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a80473c412499e9a120c4597a34add129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::qmutualinfo </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsysA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsysB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantum mutual information between 2 subsystems of a composite system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">subsysA</td><td>Indexes of the first subsystem </td></tr>
    <tr><td class="paramname">subsysB</td><td>Indexes of the second subsystem </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutual information between the 2 subsystems </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a80473c412499e9a120c4597a34add129_cgraph.png" border="0" usemap="#namespaceqpp_a80473c412499e9a120c4597a34add129_cgraph" alt=""/></div>
<map name="namespaceqpp_a80473c412499e9a120c4597a34add129_cgraph" id="namespaceqpp_a80473c412499e9a120c4597a34add129_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="533,122,668,164"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="317,256,485,283"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="533,274,668,316"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="334,510,469,552"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#aed2221e974a69e3f1c39006bcdf50738" title="qpp::internal::_check\l_subsys_match_dims" alt="" coords="328,576,475,617"/><area shape="rect" id="node7" href="namespaceqpp.html#a5fef47d40c93533b586f9b90a97c3621" title="Partial trace. " alt="" coords="175,408,262,435"/><area shape="rect" id="node10" href="namespaceqpp.html#a3642532b9a23be1c7f7cafa4629e6d5d" title="Shannon/von&#45;Neumann entropy of the probability distribution/density matrix A. " alt="" coords="168,155,269,182"/><area shape="rect" id="node8" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="323,408,480,435"/><area shape="rect" id="node9" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="323,459,480,486"/><area shape="rect" id="node11" href="namespaceqpp_1_1internal.html#ad27f82cc41710292417948f5f4b91999" title="qpp::internal::_check\l_vector" alt="" coords="334,38,469,80"/><area shape="rect" id="node12" href="namespaceqpp.html#a96eb6e12c5bc0c544663f6705bc1c950" title="Hermitian eigenvalues. " alt="" coords="357,155,446,182"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af62c1a613ce4252c37eb12fb5b8f009f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived qpp::rand </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random matrix with entries uniformly distributed in the interval [a, b) </p>
<p>If complex, then both real and imaginary parts are uniformly distributed in [a, b)</p>
<p>This is the generic version that always throws <em><a class="el" href="classqpp_1_1_exception.html#a91985c96dc408d3538b8f88cf1eaae7ca4e1a1a494e699e494ab9368f62629530" title="UNDEFINED_TYPE. ">qpp::Exception::Type::UNDEFINED_TYPE</a></em>. It is specialized only for <em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em> and <em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em> </p>

</div>
</div>
<a class="anchor" id="a6ef453d90b3165bc013e62bf952e5f84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> qpp::rand </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random real matrix with entries uniformly distributed in the interval [a, b), specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXd, with entries uniformly distributed in [-1,1)</span></div>
<div class="line"><span class="keyword">auto</span> mat = rand&lt;dmat&gt;(3, 3, -1, 1);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a768c04399d0c1cf14fc509bf86a1030e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::rand </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random complex matrix with entries (both real and imaginary) uniformly distributed in the interval [a, b), specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXcd, with entries (both real and imaginary) uniformly distributed in [-1,1)</span></div>
<div class="line"><span class="keyword">auto</span> mat = rand&lt;cmat&gt;(3, 3, -1, 1);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random complex matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a768c04399d0c1cf14fc509bf86a1030e_cgraph.png" border="0" usemap="#namespaceqpp_a768c04399d0c1cf14fc509bf86a1030e_cgraph" alt=""/></div>
<map name="namespaceqpp_a768c04399d0c1cf14fc509bf86a1030e_cgraph" id="namespaceqpp_a768c04399d0c1cf14fc509bf86a1030e_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#af62c1a613ce4252c37eb12fb5b8f009f" title="Generates a random matrix with entries uniformly distributed in the interval [a, b) ..." alt="" coords="129,5,205,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a98a75700e99974758b39948e65536407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::rand </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random real number uniformly distributed in the interval [a, b) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real number (double) uniformly distributed in the interval [a, b) </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a98a75700e99974758b39948e65536407_cgraph.png" border="0" usemap="#namespaceqpp_a98a75700e99974758b39948e65536407_cgraph" alt=""/></div>
<map name="namespaceqpp_a98a75700e99974758b39948e65536407_cgraph" id="namespaceqpp_a98a75700e99974758b39948e65536407_cgraph">
<area shape="rect" id="node2" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802" title="qpp::internal::Singleton\l\&lt; RandomDevices \&gt;::get\l_instance" alt="" coords="129,5,292,61"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5a2a1d87be74a4d0d3cbbca6245417b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randH </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random Hermitian matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random Hermitian matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a5a2a1d87be74a4d0d3cbbca6245417b5_cgraph.png" border="0" usemap="#namespaceqpp_a5a2a1d87be74a4d0d3cbbca6245417b5_cgraph" alt=""/></div>
<map name="namespaceqpp_a5a2a1d87be74a4d0d3cbbca6245417b5_cgraph" id="namespaceqpp_a5a2a1d87be74a4d0d3cbbca6245417b5_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="139,13,227,39"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="275,5,409,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aaa8b50941df1b415f0b62a2825211f73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int qpp::randint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em> = <code>std::numeric_limits&lt;int&gt;::min()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em> = <code>std::numeric_limits&lt;int&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random integer (int) uniformly distributed in the interval [a, b]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Beginning of the interval, belongs to it </td></tr>
    <tr><td class="paramname">b</td><td>End of the interval, does not belong to it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random integer (int) uniformly distributed in the interval [a, b] </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_aaa8b50941df1b415f0b62a2825211f73_cgraph.png" border="0" usemap="#namespaceqpp_aaa8b50941df1b415f0b62a2825211f73_cgraph" alt=""/></div>
<map name="namespaceqpp_aaa8b50941df1b415f0b62a2825211f73_cgraph" id="namespaceqpp_aaa8b50941df1b415f0b62a2825211f73_cgraph">
<area shape="rect" id="node2" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802" title="qpp::internal::Singleton\l\&lt; RandomDevices \&gt;::get\l_instance" alt="" coords="141,5,304,61"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa8860e7f282dfd5a75b1292303bd703d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#add021f91288df8af3125cf4b2c8806e6">ket</a> qpp::randket </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random normalized ket (pure state vector) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random normalized ket </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_aa8860e7f282dfd5a75b1292303bd703d_cgraph.png" border="0" usemap="#namespaceqpp_aa8860e7f282dfd5a75b1292303bd703d_cgraph" alt=""/></div>
<map name="namespaceqpp_aa8860e7f282dfd5a75b1292303bd703d_cgraph" id="namespaceqpp_aa8860e7f282dfd5a75b1292303bd703d_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#af2e4740854c958579228593dd639aa6c" title="Frobenius norm. " alt="" coords="145,13,224,39"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="272,5,407,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad7a6e123647482a1673a51aa74aa6ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a>&gt; qpp::randkraus </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a set of random Kraus operators. </p>
<dl class="section note"><dt>Note</dt><dd>The set of Kraus operators satisfy the closure condition <img class="formulaInl" alt="$ \sum_i K_i^\dagger K_i = I$" src="form_21.png"/></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Number of Kraus operators </td></tr>
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set of <em>N</em> Kraus operators satisfying the closure condition </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ad7a6e123647482a1673a51aa74aa6ca2_cgraph.png" border="0" usemap="#namespaceqpp_ad7a6e123647482a1673a51aa74aa6ca2_cgraph" alt=""/></div>
<map name="namespaceqpp_ad7a6e123647482a1673a51aa74aa6ca2_cgraph" id="namespaceqpp_ad7a6e123647482a1673a51aa74aa6ca2_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a5c63023791941918aad0894de4ba1eb7" title="Generates a random unitary matrix. " alt="" coords="160,5,245,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="adb5c9d92baf1749ca84aa099e7991bd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived qpp::randn </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random matrix with entries normally distributed in N(mean, sigma) </p>
<p>If complex, then both real and imaginary parts are normally distributed in N(mean, sigma)</p>
<p>This is the generic version that always throws <em><a class="el" href="classqpp_1_1_exception.html#a91985c96dc408d3538b8f88cf1eaae7ca4e1a1a494e699e494ab9368f62629530" title="UNDEFINED_TYPE. ">qpp::Exception::Type::UNDEFINED_TYPE</a></em>. It is specialized only for <em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em> and <em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em> </p>

</div>
</div>
<a class="anchor" id="a351821ffae682d9365179225a46de1ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86">dmat</a> qpp::randn </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random real matrix with entries normally distributed in N(mean, sigma), specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXd, with entries normally distributed in N(0,2)</span></div>
<div class="line"><span class="keyword">auto</span> mat = randn&lt;dmat&gt;(3, 3, 0, 2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a351821ffae682d9365179225a46de1ea_cgraph.png" border="0" usemap="#namespaceqpp_a351821ffae682d9365179225a46de1ea_cgraph" alt=""/></div>
<map name="namespaceqpp_a351821ffae682d9365179225a46de1ea_cgraph" id="namespaceqpp_a351821ffae682d9365179225a46de1ea_cgraph">
<area shape="rect" id="node2" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802" title="qpp::internal::Singleton\l\&lt; RandomDevices \&gt;::get\l_instance" alt="" coords="136,5,299,61"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a219b46bbd2051993d38e7557da12cb47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randn </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a random complex matrix with entries (both real and imaginary) normally distributed in N(mean, sigma), specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </p>
<p>The template parameter cannot be automatically deduced and must be explicitly provided</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// generates a 3 x 3 random Eigen::MatrixXcd, with entries (both real and imaginary) normally distributed in N(0,2)</span></div>
<div class="line"><span class="keyword">auto</span> mat = randn&lt;cmat&gt;(3, 3, 0, 2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Number of rows of the random generated matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the random generated matrix </td></tr>
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random complex matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a219b46bbd2051993d38e7557da12cb47_cgraph.png" border="0" usemap="#namespaceqpp_a219b46bbd2051993d38e7557da12cb47_cgraph" alt=""/></div>
<map name="namespaceqpp_a219b46bbd2051993d38e7557da12cb47_cgraph" id="namespaceqpp_a219b46bbd2051993d38e7557da12cb47_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#adb5c9d92baf1749ca84aa099e7991bd5" title="Generates a random matrix with entries normally distributed in N(mean, sigma) " alt="" coords="136,5,219,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab967280114b9e2003bd559c840a5f0e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double qpp::randn </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random real number (double) normally distributed in N(mean, sigma) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>Mean </td></tr>
    <tr><td class="paramname">sigma</td><td>Standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random real number normally distributed in N(mean, sigma) </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ab967280114b9e2003bd559c840a5f0e6_cgraph.png" border="0" usemap="#namespaceqpp_ab967280114b9e2003bd559c840a5f0e6_cgraph" alt=""/></div>
<map name="namespaceqpp_ab967280114b9e2003bd559c840a5f0e6_cgraph" id="namespaceqpp_ab967280114b9e2003bd559c840a5f0e6_cgraph">
<area shape="rect" id="node2" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802" title="qpp::internal::Singleton\l\&lt; RandomDevices \&gt;::get\l_instance" alt="" coords="136,5,299,61"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6375dff8dd558f524bc0e7d3e261100f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; qpp::randperm </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random uniformly distributed permutation. </p>
<p>Uses Knuth's shuffle method (as implemented by std::shuffle), so that all permutations are equally probable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Size of the permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random permutation of size <em>n</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a6375dff8dd558f524bc0e7d3e261100f_cgraph.png" border="0" usemap="#namespaceqpp_a6375dff8dd558f524bc0e7d3e261100f_cgraph" alt=""/></div>
<map name="namespaceqpp_a6375dff8dd558f524bc0e7d3e261100f_cgraph" id="namespaceqpp_a6375dff8dd558f524bc0e7d3e261100f_cgraph">
<area shape="rect" id="node2" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802" title="qpp::internal::Singleton\l\&lt; RandomDevices \&gt;::get\l_instance" alt="" coords="157,5,320,61"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5751166c3171415976bd5aab3e5b70f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randrho </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random density matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random density matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a5751166c3171415976bd5aab3e5b70f5_cgraph.png" border="0" usemap="#namespaceqpp_a5751166c3171415976bd5aab3e5b70f5_cgraph" alt=""/></div>
<map name="namespaceqpp_a5751166c3171415976bd5aab3e5b70f5_cgraph" id="namespaceqpp_a5751166c3171415976bd5aab3e5b70f5_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a5a2a1d87be74a4d0d3cbbca6245417b5" title="Generates a random Hermitian matrix. " alt="" coords="147,5,232,32"/><area shape="rect" id="node3" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="280,56,368,83"/><area shape="rect" id="node5" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54" title="Trace. " alt="" coords="285,107,363,133"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="416,74,551,115"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5c63023791941918aad0894de4ba1eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randU </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random unitary matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Dimension of the Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random unitary </dd></dl>

</div>
</div>
<a class="anchor" id="ac2f080960f87046e3b886dcd83f292bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::randV </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>Din</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>Dout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random isometry matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Din</td><td>Size of the input Hilbert space </td></tr>
    <tr><td class="paramname">Dout</td><td>Size of the output Hilbert space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random isometry matrix </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ac2f080960f87046e3b886dcd83f292bd_cgraph.png" border="0" usemap="#namespaceqpp_ac2f080960f87046e3b886dcd83f292bd_cgraph" alt=""/></div>
<map name="namespaceqpp_ac2f080960f87046e3b886dcd83f292bd_cgraph" id="namespaceqpp_ac2f080960f87046e3b886dcd83f292bd_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a5c63023791941918aad0894de4ba1eb7" title="Generates a random unitary matrix. " alt="" coords="139,5,224,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a991bc6df4280943452bfbedafa65b9f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::renyi </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy of the probability distribution/density matrix <em>A</em>, for <img class="formulaInl" alt="$ \alpha\geq 0$" src="form_11.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, representing a probability distribution (real dynamic column vector) or a density matrix (complex dynamic matrix) </td></tr>
    <tr><td class="paramname">alpha</td><td>Non-negative real number, use <a class="el" href="namespaceqpp.html#a33b4878f2b40f0dafeb5a437bfd88351" title="Used to denote infinity. ">qpp::infty</a> for <img class="formulaInl" alt="$\alpha = \infty$" src="form_12.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy, with the logarithm in base 2 </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a991bc6df4280943452bfbedafa65b9f7_cgraph.png" border="0" usemap="#namespaceqpp_a991bc6df4280943452bfbedafa65b9f7_cgraph" alt=""/></div>
<map name="namespaceqpp_a991bc6df4280943452bfbedafa65b9f7_cgraph" id="namespaceqpp_a991bc6df4280943452bfbedafa65b9f7_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a3642532b9a23be1c7f7cafa4629e6d5d" title="Shannon/von&#45;Neumann entropy of the probability distribution/density matrix A. " alt="" coords="131,131,232,158"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="463,214,597,256"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ad27f82cc41710292417948f5f4b91999" title="qpp::internal::_check\l_vector" alt="" coords="280,29,415,70"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="463,88,597,129"/><area shape="rect" id="node7" href="namespaceqpp.html#a51e1199f56fdc39622a17c949d6ede5a" title="Singular values. " alt="" coords="140,298,223,324"/><area shape="rect" id="node6" href="namespaceqpp.html#a96eb6e12c5bc0c544663f6705bc1c950" title="Hermitian eigenvalues. " alt="" coords="303,146,392,172"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1f5c91b44c2437627777140980cac940"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::reshape </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshape. </p>
<p>Uses column-major order when reshaping (same as MATLAB)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">rows</td><td>Number of rows of the reshaped matrix </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns of the reshaped matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reshaped matrix with <em>rows</em> rows and <em>cols</em> columns, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a1f5c91b44c2437627777140980cac940_cgraph.png" border="0" usemap="#namespaceqpp_a1f5c91b44c2437627777140980cac940_cgraph" alt=""/></div>
<map name="namespaceqpp_a1f5c91b44c2437627777140980cac940_cgraph" id="namespaceqpp_a1f5c91b44c2437627777140980cac940_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="152,5,287,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a238cf516513837235fbc7d7d283f7b78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qpp::save </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves Eigen expression to a binary file (internal format) in double precision. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a38d10a1f7c02f69d876a28133893d082" title="Saves an Eigen dynamic matrix to a MATLAB .mat file, generic version. ">qpp::saveMATLABmatrix()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">fname</td><td>Output file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38d10a1f7c02f69d876a28133893d082"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qpp::saveMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves an Eigen dynamic matrix to a MATLAB .mat file, generic version. </p>
<p>This is the generic version that always throws <em><a class="el" href="classqpp_1_1_exception.html#a91985c96dc408d3538b8f88cf1eaae7ca4e1a1a494e699e494ab9368f62629530" title="UNDEFINED_TYPE. ">qpp::Exception::Type::UNDEFINED_TYPE</a></em>. It is specialized only for <em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em> and <em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em> (the only matrix types that can be saved) </p>

</div>
</div>
<a class="anchor" id="a37a40410f15a82495cabcd3641a788cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qpp::saveMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; dmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves an Eigen dynamic matrix to a MATLAB .mat file, specialization for double matrices (<em><a class="el" href="namespaceqpp.html#a31d63fc80c90b84ab9ab7062f2d82d86" title="Real (double precision) dynamic Eigen matrix. ">qpp::dmat</a></em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression over the complex field </td></tr>
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be saved </td></tr>
    <tr><td class="paramname">mode</td><td>Saving mode (append, overwrite etc.), see MATLAB's <em>matOpen()</em> documentation for details </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a37a40410f15a82495cabcd3641a788cd_cgraph.png" border="0" usemap="#namespaceqpp_a37a40410f15a82495cabcd3641a788cd_cgraph" alt=""/></div>
<map name="namespaceqpp_a37a40410f15a82495cabcd3641a788cd_cgraph" id="namespaceqpp_a37a40410f15a82495cabcd3641a788cd_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="219,5,353,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2f5cc697b513a7f0e5bdab3f357df173"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qpp::saveMATLABmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mat_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves an Eigen dynamic matrix to a MATLAB .mat file, specialization for complex matrices (<em><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328" title="Complex (double precision) dynamic Eigen matrix. ">qpp::cmat</a></em>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression over the complex field </td></tr>
    <tr><td class="paramname">mat_file</td><td>MATALB .mat file </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name in the .mat file representing the matrix to be saved </td></tr>
    <tr><td class="paramname">mode</td><td>Saving mode (append, overwrite etc.), see MATLAB's <em>matOpen()</em> documentation for details </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a2f5cc697b513a7f0e5bdab3f357df173_cgraph.png" border="0" usemap="#namespaceqpp_a2f5cc697b513a7f0e5bdab3f357df173_cgraph" alt=""/></div>
<map name="namespaceqpp_a2f5cc697b513a7f0e5bdab3f357df173_cgraph" id="namespaceqpp_a2f5cc697b513a7f0e5bdab3f357df173_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="219,5,353,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8251985eb390022a0116f6572a82ea58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::schatten </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schatten norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">p</td><td>Integer, greater or equal to 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schatten-<em>p</em> norm of <em>A</em>, as a real number </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a8251985eb390022a0116f6572a82ea58_cgraph.png" border="0" usemap="#namespaceqpp_a8251985eb390022a0116f6572a82ea58_cgraph" alt=""/></div>
<map name="namespaceqpp_a8251985eb390022a0116f6572a82ea58_cgraph" id="namespaceqpp_a8251985eb390022a0116f6572a82ea58_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="687,213,821,254"/><area shape="rect" id="node3" href="namespaceqpp.html#a51e1199f56fdc39622a17c949d6ede5a" title="Singular values. " alt="" coords="420,43,503,69"/><area shape="rect" id="node4" href="namespaceqpp.html#a1e1daff5450728504da1fdfedf8d8b54" title="Trace. " alt="" coords="155,93,233,120"/><area shape="rect" id="node5" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="551,499,638,525"/><area shape="rect" id="node7" href="namespaceqpp.html#a3a4cb16d97f9cc763bd133b64f2b6f6d" title="Matrix absolut value. " alt="" coords="152,195,236,221"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="687,466,821,507"/><area shape="rect" id="node8" href="namespaceqpp.html#a83e2b23bc11e3cb8dd6909969af7377c" title="Matrix square root. " alt="" coords="287,296,369,323"/><area shape="rect" id="node12" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="284,195,372,221"/><area shape="rect" id="node9" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="422,347,501,373"/><area shape="rect" id="node10" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="551,397,639,424"/><area shape="rect" id="node11" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="553,347,636,373"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a810c85eb9d8b64d7b42655713d7c16f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;<a class="el" href="namespaceqpp.html#aad7ccc50a6b139279d7b56d07112b183">cplx</a>&gt; qpp::schmidtcoeff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt coefficients of the bi-partite pure state <em>A</em>. </p>
<dl class="section note"><dt>Note</dt><dd>The sum of the squares of the Schmidt coefficients equals 1 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#ad23896bc52b516135d0ce545f8149bfc" title="Schmidt probabilities of the bi-partite pure state A. ">qpp::schmidtprob()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schmidt coefficients of <em>A</em>, as a complex dynamic column vector </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a810c85eb9d8b64d7b42655713d7c16f3_cgraph.png" border="0" usemap="#namespaceqpp_a810c85eb9d8b64d7b42655713d7c16f3_cgraph" alt=""/></div>
<map name="namespaceqpp_a810c85eb9d8b64d7b42655713d7c16f3_cgraph" id="namespaceqpp_a810c85eb9d8b64d7b42655713d7c16f3_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="355,161,489,202"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="172,37,307,78"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="172,102,307,143"/><area shape="rect" id="node5" href="namespaceqpp.html#a7b652e3ea4b9748204359a69588a8c91" title="Transpose. " alt="" coords="185,168,293,195"/><area shape="rect" id="node6" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940" title="Reshape. " alt="" coords="190,219,289,245"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad23896bc52b516135d0ce545f8149bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;double&gt; qpp::schmidtprob </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt probabilities of the bi-partite pure state <em>A</em>. </p>
<p>Defined as the squares of the Schmidt coefficients<br />
The sum of the Schmidt probabilities equals 1 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceqpp.html#a810c85eb9d8b64d7b42655713d7c16f3" title="Schmidt coefficients of the bi-partite pure state A. ">qpp::schmidtcoeff()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schmidt probabilites of <em>A</em>, as a real dynamic column vector </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_ad23896bc52b516135d0ce545f8149bfc_cgraph.png" border="0" usemap="#namespaceqpp_ad23896bc52b516135d0ce545f8149bfc_cgraph" alt=""/></div>
<map name="namespaceqpp_ad23896bc52b516135d0ce545f8149bfc_cgraph" id="namespaceqpp_ad23896bc52b516135d0ce545f8149bfc_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="355,181,489,222"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="172,38,307,80"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="172,104,307,145"/><area shape="rect" id="node5" href="namespaceqpp.html#a7b652e3ea4b9748204359a69588a8c91" title="Transpose. " alt="" coords="185,170,293,196"/><area shape="rect" id="node6" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940" title="Reshape. " alt="" coords="190,220,289,247"/><area shape="rect" id="node7" href="namespaceqpp.html#a3b4fd08d05e83656e8ce3153fe5a6f0b" title="Matrix power. " alt="" coords="196,271,283,298"/><area shape="rect" id="node8" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="355,264,489,305"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a08b14c1fbfface136d6c42fe28461c3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::schmidtU </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt basis on Alice's side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unitary matrix <img class="formulaInl" alt="$ U $" src="form_8.png"/> whose columns represent the Schmidt basis vectors on Alice's side. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a08b14c1fbfface136d6c42fe28461c3a_cgraph.png" border="0" usemap="#namespaceqpp_a08b14c1fbfface136d6c42fe28461c3a_cgraph" alt=""/></div>
<map name="namespaceqpp_a08b14c1fbfface136d6c42fe28461c3a_cgraph" id="namespaceqpp_a08b14c1fbfface136d6c42fe28461c3a_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="339,188,473,230"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="156,39,291,80"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="156,104,291,146"/><area shape="rect" id="node5" href="namespaceqpp.html#a33c070beade098fa8f26440791cc8840" title="Left singular vectors. " alt="" coords="183,170,264,197"/><area shape="rect" id="node6" href="namespaceqpp.html#a7b652e3ea4b9748204359a69588a8c91" title="Transpose. " alt="" coords="169,221,277,248"/><area shape="rect" id="node7" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940" title="Reshape. " alt="" coords="174,272,273,298"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a015680bd06d6832f6c1e8b314a74339f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::schmidtV </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schmidt basis on Bob's side. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the bi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unitary matrix <img class="formulaInl" alt="$ V $" src="form_9.png"/> whose columns represent the Schmidt basis vectors on Bob's side. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a015680bd06d6832f6c1e8b314a74339f_cgraph.png" border="0" usemap="#namespaceqpp_a015680bd06d6832f6c1e8b314a74339f_cgraph" alt=""/></div>
<map name="namespaceqpp_a015680bd06d6832f6c1e8b314a74339f_cgraph" id="namespaceqpp_a015680bd06d6832f6c1e8b314a74339f_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="339,215,473,256"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="156,40,291,82"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="156,106,291,147"/><area shape="rect" id="node5" href="namespaceqpp.html#a285eda1b8ec8614398dd731e5e3a89ed" title="Right singular vectors. " alt="" coords="183,172,264,198"/><area shape="rect" id="node6" href="namespaceqpp.html#a7b652e3ea4b9748204359a69588a8c91" title="Transpose. " alt="" coords="169,222,277,249"/><area shape="rect" id="node7" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940" title="Reshape. " alt="" coords="174,273,273,300"/><area shape="rect" id="node8" href="namespaceqpp.html#acbf2df9d3f5c18623eab26ab84ea7418" title="Complex conjugate. " alt="" coords="170,324,277,350"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3642532b9a23be1c7f7cafa4629e6d5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::shannon </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shannon/von-Neumann entropy of the probability distribution/density matrix <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, representing a probability distribution (real dynamic column vector) or a density matrix (complex dynamic matrix) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shannon/von-Neumann entropy, with the logarithm in base 2 </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a3642532b9a23be1c7f7cafa4629e6d5d_cgraph.png" border="0" usemap="#namespaceqpp_a3642532b9a23be1c7f7cafa4629e6d5d_cgraph" alt=""/></div>
<map name="namespaceqpp_a3642532b9a23be1c7f7cafa4629e6d5d_cgraph" id="namespaceqpp_a3642532b9a23be1c7f7cafa4629e6d5d_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="337,9,472,50"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ad27f82cc41710292417948f5f4b91999" title="qpp::internal::_check\l_vector" alt="" coords="155,29,289,70"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="337,113,472,154"/><area shape="rect" id="node5" href="namespaceqpp.html#a96eb6e12c5bc0c544663f6705bc1c950" title="Hermitian eigenvalues. " alt="" coords="177,95,267,122"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a78be6e812878479d6acbd25cf5ae387c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::sinm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix sin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix sine of <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a78be6e812878479d6acbd25cf5ae387c_cgraph.png" border="0" usemap="#namespaceqpp_a78be6e812878479d6acbd25cf5ae387c_cgraph" alt=""/></div>
<map name="namespaceqpp_a78be6e812878479d6acbd25cf5ae387c_cgraph" id="namespaceqpp_a78be6e812878479d6acbd25cf5ae387c_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="393,12,528,53"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="393,113,528,154"/><area shape="rect" id="node4" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="131,70,209,96"/><area shape="rect" id="node5" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="257,95,345,122"/><area shape="rect" id="node6" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="260,44,343,71"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a62d7f0db6a049f254c2a7a77af8eb29e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::spectralpowm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cplx&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix power. </p>
<p>Uses the spectral decomposition of <em>A</em> to compute the matrix power<br />
By convention <img class="formulaInl" alt="$A^0 = I$" src="form_25.png"/></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">z</td><td>Complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix power <img class="formulaInl" alt="$A^z$" src="form_26.png"/> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a62d7f0db6a049f254c2a7a77af8eb29e_cgraph.png" border="0" usemap="#namespaceqpp_a62d7f0db6a049f254c2a7a77af8eb29e_cgraph" alt=""/></div>
<map name="namespaceqpp_a62d7f0db6a049f254c2a7a77af8eb29e_cgraph" id="namespaceqpp_a62d7f0db6a049f254c2a7a77af8eb29e_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="320,9,455,50"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="320,74,455,116"/><area shape="rect" id="node4" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="184,23,272,50"/><area shape="rect" id="node5" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="187,74,269,100"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a83e2b23bc11e3cb8dd6909969af7377c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::sqrtm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix square root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix square root of <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a83e2b23bc11e3cb8dd6909969af7377c_cgraph.png" border="0" usemap="#namespaceqpp_a83e2b23bc11e3cb8dd6909969af7377c_cgraph" alt=""/></div>
<map name="namespaceqpp_a83e2b23bc11e3cb8dd6909969af7377c_cgraph" id="namespaceqpp_a83e2b23bc11e3cb8dd6909969af7377c_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="397,12,532,53"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="397,113,532,154"/><area shape="rect" id="node4" href="namespaceqpp.html#a659b50e01fa0b26089d3944c2c56601a" title="Functional calculus f(A) " alt="" coords="135,70,213,96"/><area shape="rect" id="node5" href="namespaceqpp.html#acc9597bacc39c501eb8e2e5e8530fcd8" title="Eigenvectors. " alt="" coords="261,95,349,122"/><area shape="rect" id="node6" href="namespaceqpp.html#a927d85e57656ffb19ddb149985fa52df" title="Eigenvalues. " alt="" coords="264,44,347,71"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a48a92e8a327ff86f87c6236965103797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise sum of <em>A</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise sum of <em>A</em>, as a scalar in the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a48a92e8a327ff86f87c6236965103797_cgraph.png" border="0" usemap="#namespaceqpp_a48a92e8a327ff86f87c6236965103797_cgraph" alt=""/></div>
<map name="namespaceqpp_a48a92e8a327ff86f87c6236965103797_cgraph" id="namespaceqpp_a48a92e8a327ff86f87c6236965103797_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="128,5,263,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9beed28e8ce824a89484c6aeeb9ea24e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto qpp::sum </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename InputIterator::value_type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise sum of a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element of the range </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-wise sum of the range, as a scalar in the same scalar field as the range </dd></dl>

</div>
</div>
<a class="anchor" id="a54d1de5e72943a61c35ab634690a841b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::super </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cmat &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Superoperator matrix representation. </p>
<p>Constructs the superoperator matrix of the channel specified by the set of Kraus operators <em>Ks</em> in the standard operator basis <img class="formulaInl" alt="$\{|i\rangle\langle j|\}$" src="form_15.png"/> ordered in lexicographical order, i.e. <img class="formulaInl" alt="$|0\rangle\langle 0|$" src="form_16.png"/>, <img class="formulaInl" alt="$|0\rangle\langle 1|$" src="form_17.png"/> etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ks</td><td>Set of Kraus operators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Superoperator matrix representation </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a54d1de5e72943a61c35ab634690a841b_cgraph.png" border="0" usemap="#namespaceqpp_a54d1de5e72943a61c35ab634690a841b_cgraph" alt=""/></div>
<map name="namespaceqpp_a54d1de5e72943a61c35ab634690a841b_cgraph" id="namespaceqpp_a54d1de5e72943a61c35ab634690a841b_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="319,26,453,67"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="136,26,271,67"/><area shape="rect" id="node4" href="namespaceqpp.html#ac541afad6657467d9bd83c69345880a2" title="Adjoint. " alt="" coords="159,92,247,118"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a51e1199f56fdc39622a17c949d6ede5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a23060a9e83c7da740a4459153dbd2c41">DynColVect</a>&lt;double&gt; qpp::svals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Singular values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Singular values of <em>A</em>, as a real dynamic column vector </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a51e1199f56fdc39622a17c949d6ede5a_cgraph.png" border="0" usemap="#namespaceqpp_a51e1199f56fdc39622a17c949d6ede5a_cgraph" alt=""/></div>
<map name="namespaceqpp_a51e1199f56fdc39622a17c949d6ede5a_cgraph" id="namespaceqpp_a51e1199f56fdc39622a17c949d6ede5a_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="136,5,271,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a33c070beade098fa8f26440791cc8840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::svdU </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left singular vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex dynamic matrix, whose columns are the left singular vectors of <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a33c070beade098fa8f26440791cc8840_cgraph.png" border="0" usemap="#namespaceqpp_a33c070beade098fa8f26440791cc8840_cgraph" alt=""/></div>
<map name="namespaceqpp_a33c070beade098fa8f26440791cc8840_cgraph" id="namespaceqpp_a33c070beade098fa8f26440791cc8840_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="135,5,269,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a285eda1b8ec8614398dd731e5e3a89ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a8b7b2a88cebcdddfde04c087eecf1328">cmat</a> qpp::svdV </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right singular vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Complex dynamic matrix, whose columns are the right singular vectors of <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a285eda1b8ec8614398dd731e5e3a89ed_cgraph.png" border="0" usemap="#namespaceqpp_a285eda1b8ec8614398dd731e5e3a89ed_cgraph" alt=""/></div>
<map name="namespaceqpp_a285eda1b8ec8614398dd731e5e3a89ed_cgraph" id="namespaceqpp_a285eda1b8ec8614398dd731e5e3a89ed_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="135,5,269,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af97cab67fadb870ad19be297b4422ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::syspermute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System permutation. </p>
<p>Permutes the subsystems in a state vector or density matrix<br />
The qubit <em>perm</em>[<em>i</em>] is permuted to the location <em>i</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
    <tr><td class="paramname">perm</td><td>Permutation </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of the multi-partite system </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Permuted system, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_af97cab67fadb870ad19be297b4422ca1_cgraph.png" border="0" usemap="#namespaceqpp_af97cab67fadb870ad19be297b4422ca1_cgraph" alt=""/></div>
<map name="namespaceqpp_af97cab67fadb870ad19be297b4422ca1_cgraph" id="namespaceqpp_af97cab67fadb870ad19be297b4422ca1_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="389,248,524,289"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a8b3940aa8b60b8eeb411db0f3802503b" title="qpp::internal::_check_dims" alt="" coords="172,47,340,74"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ad74950dff6c5fa14902ff599e56f1960" title="qpp::internal::_check_perm" alt="" coords="171,98,341,125"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#ad6e3c598a9985bac31f86dc916151b80" title="qpp::internal::_n2multiidx" alt="" coords="177,149,335,175"/><area shape="rect" id="node6" href="namespaceqpp_1_1internal.html#a7ab3b0b016ffd0eb793ea6281bed9fc0" title="qpp::internal::_multiidx2n" alt="" coords="177,199,335,226"/><area shape="rect" id="node7" href="namespaceqpp_1_1internal.html#add886736621946a87cbc404ad955a605" title="qpp::internal::_check\l_col_vector" alt="" coords="189,251,323,292"/><area shape="rect" id="node8" href="namespaceqpp_1_1internal.html#a49b8ec606333c1cf8da35aa42e94c528" title="qpp::internal::_check\l_dims_match_cvect" alt="" coords="189,316,323,357"/><area shape="rect" id="node9" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="189,381,323,423"/><area shape="rect" id="node10" href="namespaceqpp_1_1internal.html#a54738d7b62e4c9a0489bf56f45096894" title="qpp::internal::_check\l_dims_match_mat" alt="" coords="189,447,323,488"/><area shape="rect" id="node11" href="namespaceqpp.html#a1f5c91b44c2437627777140980cac940" title="Reshape. " alt="" coords="207,513,305,539"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1e1daff5450728504da1fdfedf8d8b54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar qpp::trace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trace of <em>A</em>, as a scalar in the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a1e1daff5450728504da1fdfedf8d8b54_cgraph.png" border="0" usemap="#namespaceqpp_a1e1daff5450728504da1fdfedf8d8b54_cgraph" alt=""/></div>
<map name="namespaceqpp_a1e1daff5450728504da1fdfedf8d8b54_cgraph" id="namespaceqpp_a1e1daff5450728504da1fdfedf8d8b54_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="132,5,267,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7b652e3ea4b9748204359a69588a8c91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceqpp.html#a39fdcbcd3a12dd426ceab6d4aec4a281">DynMat</a>&lt;typename Derived::Scalar&gt; qpp::transpose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transpose of <em>A</em>, as a dynamic matrix over the same scalar field as <em>A</em> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a7b652e3ea4b9748204359a69588a8c91_cgraph.png" border="0" usemap="#namespaceqpp_a7b652e3ea4b9748204359a69588a8c91_cgraph" alt=""/></div>
<map name="namespaceqpp_a7b652e3ea4b9748204359a69588a8c91_cgraph" id="namespaceqpp_a7b652e3ea4b9748204359a69588a8c91_cgraph">
<area shape="rect" id="node2" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="161,5,296,47"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4980e688af46b3b1a96c2f12c9849cd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double qpp::tsallis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tsallis- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy of the probability distribution/density matrix <em>A</em>, for <img class="formulaInl" alt="$ \alpha\geq 0$" src="form_11.png"/><br />
. </p>
<p>When <img class="formulaInl" alt="$ \alpha\to 1$" src="form_13.png"/> the Tsallis entropy converges to the Shannon/von-Neumann entropy, with the logarithm in base <img class="formulaInl" alt="$ e $" src="form_14.png"/></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Eigen expression, representing a probability distribution (real dynamic column vector) or a density matrix (complex dynamic matrix) </td></tr>
    <tr><td class="paramname">alpha</td><td>Non-negative real number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Renyi- <img class="formulaInl" alt="$\alpha$" src="form_10.png"/> entropy, with the logarithm in base 2 </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceqpp_a4980e688af46b3b1a96c2f12c9849cd0_cgraph.png" border="0" usemap="#namespaceqpp_a4980e688af46b3b1a96c2f12c9849cd0_cgraph" alt=""/></div>
<map name="namespaceqpp_a4980e688af46b3b1a96c2f12c9849cd0_cgraph" id="namespaceqpp_a4980e688af46b3b1a96c2f12c9849cd0_cgraph">
<area shape="rect" id="node2" href="namespaceqpp.html#a3642532b9a23be1c7f7cafa4629e6d5d" title="Shannon/von&#45;Neumann entropy of the probability distribution/density matrix A. " alt="" coords="136,114,237,140"/><area shape="rect" id="node3" href="namespaceqpp_1_1internal.html#a62ab44d343a116c122e488bc3ac46a31" title="qpp::internal::_check\l_nonzero_size" alt="" coords="468,17,603,58"/><area shape="rect" id="node4" href="namespaceqpp_1_1internal.html#ad27f82cc41710292417948f5f4b91999" title="qpp::internal::_check\l_vector" alt="" coords="285,177,420,218"/><area shape="rect" id="node5" href="namespaceqpp_1_1internal.html#ace7cfa182baf987f8a3374bd700b4276" title="qpp::internal::_check\l_square_mat" alt="" coords="468,118,603,160"/><area shape="rect" id="node6" href="namespaceqpp.html#a96eb6e12c5bc0c544663f6705bc1c950" title="Hermitian eigenvalues. " alt="" coords="308,24,397,51"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a569c5700863d7054bea8e36f26d9930b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; qpp::x2contfrac </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cut</em> = <code>1e5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple continued fraction expansion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Real number </td></tr>
    <tr><td class="paramname">n</td><td>Number of terms in the expansion </td></tr>
    <tr><td class="paramname">cut</td><td>Stop the expansion when the next term is greater than <em>cut</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer vector containing the simple continued fraction expansion of <em>x</em>. If there are <em>m</em> less than <em>n</em> terms in the expansion, a shorter vector with <em>m</em> components is returned. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a3a6d2c509bdcf240869e1bebb3be4e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::chop = 1e-10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used in <a class="el" href="namespaceqpp.html#a4f1805e175751ef749374e3c8499f15d" title="Eigen expression ostream manipulator. ">qpp::disp()</a> and <a class="el" href="namespaceqpp_1_1experimental.html#af4fec399593b70b3d54f213500807569" title="Displays a range. Adds a newline. ">qpp::displn()</a> for setting to zero numbers that have their absolute value smaller than qpp::ct::chop. </p>

</div>
</div>
<a class="anchor" id="a3af5132edaed29c8d8233d1bb6ffa47a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classqpp_1_1_codes.html">Codes</a>&amp; qpp::codes = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Codes::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_codes.html" title="const Singleton class that defines quantum error correcting codes ">qpp::Codes</a> const Singleton </p>
<p>Initializes the codes, see the class <em><a class="el" href="classqpp_1_1_codes.html" title="const Singleton class that defines quantum error correcting codes ">qpp::Codes</a></em> </p>

</div>
</div>
<a class="anchor" id="aca5c7e10fa94db0755cb937250144630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::ee = 2.718281828459045235360287471352662497</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base of natural logarithm, <img class="formulaInl" alt="$e$" src="form_6.png"/>. </p>

</div>
</div>
<a class="anchor" id="a9a99ccccd473a9006dfaadb5761ac4f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::eps = 1e-12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to decide whether a number or expression in double precision is zero or not. </p>
<p>Example:</p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(std::abs(x) &lt; <a class="code" href="namespaceqpp.html#a9a99ccccd473a9006dfaadb5761ac4f6">qpp::eps</a>) <span class="comment">// x is zero </span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abde5be3693c953f79e9c8e262447c8d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classqpp_1_1_gates.html">Gates</a>&amp; qpp::gt = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Gates::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_gates.html" title="const Singleton class that implements most commonly used gates ">qpp::Gates</a> const Singleton </p>
<p>Initializes the gates, see the class <em><a class="el" href="classqpp_1_1_gates.html" title="const Singleton class that implements most commonly used gates ">qpp::Gates</a></em> </p>

</div>
</div>
<a class="anchor" id="a33b4878f2b40f0dafeb5a437bfd88351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t qpp::infty = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to denote infinity. </p>

</div>
</div>
<a class="anchor" id="aca4969dadb784a76f5182b791fb54198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classqpp_1_1_init.html">Init</a>&amp; qpp::init = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">Init::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_init.html" title="const Singleton class that performs additional initializations/cleanups ">qpp::Init</a> const Singleton </p>
<p>Additional initializations/cleanups </p>

</div>
</div>
<a class="anchor" id="a9cb5b9cd86de8efebf531f22f673489a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t qpp::maxn = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of qubits. </p>
<p>Used internally to allocate arrays on the stack (for speed reasons) </p>

</div>
</div>
<a class="anchor" id="a73c04db6f636b236d64fddb069bef492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double qpp::pi = 3.141592653589793238462643383279502884</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><img class="formulaInl" alt="$ \pi $" src="form_5.png"/> </p>

</div>
</div>
<a class="anchor" id="ae470c1750d1cc895763d1902f3a6882d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqpp_1_1_random_devices.html">RandomDevices</a>&amp; qpp::rdevs = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">RandomDevices::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_random_devices.html" title="Singeleton class that manages the source of randomness in the library. ">qpp::RandomDevices</a> Singleton </p>
<p>Initializes the random devices, see the class <em><a class="el" href="classqpp_1_1_random_devices.html" title="Singeleton class that manages the source of randomness in the library. ">qpp::RandomDevices</a></em> </p>

</div>
</div>
<a class="anchor" id="a8cf42bdf7cdbcc98543c7bf6ef36671d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classqpp_1_1_states.html">States</a>&amp; qpp::st = <a class="el" href="classqpp_1_1internal_1_1_singleton.html#a65f1068804fafa264c2a6adabbe35802">States::get_instance</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classqpp_1_1_states.html" title="const Singleton class that implements most commonly used states ">qpp::States</a> const Singleton </p>
<p>Initializes the states, see the class <em><a class="el" href="classqpp_1_1_states.html" title="const Singleton class that implements most commonly used states ">qpp::States</a></em> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceqpp.html">qpp</a></li>
    <li class="footer">Generated on Tue Nov 11 2014 22:51:44 for quantum++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
